<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// DO NOT CHANGE THIS FILE.
// </auto-generated>
using Kzrnm.Competitive.Internal;
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using 凾 = System.Runtime.CompilerServices.MethodImplAttribute;

namespace Kzrnm.Competitive
{
    public readonly struct <#= matrixName #> : IMatrix<<#= matrixName #>, T>
        , IMultiplyOperators<<#= matrixName #>, T, <#= matrixName #>>
        where T : INumberBase<T>
    {
        public int Height => <#= size #>;
        public int Width => <#= size #>;
<# for (int i = 0; i < size; i++) { #>
        public <#= tupleName #> Row<#= i #> => (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"V{i}{c}")) #>);
<# } #>
        internal readonly T
<# for (int i = 0; i < size; i++) { #>
            <#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"V{i}{c}")) #><#= i+1<size?",":";" #>
<# } #>
        [凾(256)] public ReadOnlySpan<T> AsSpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<<#= matrixName #>, T>(ref Unsafe.AsRef(this)), <#= size #> * <#= size #>);
        public T[][] ToArray() => new[]
        {
<# for (int i = 0; i < size; i++) { #>
            new[]{ <#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"V{i}{c}")) #> },
<# } #>
        };
        [凾(256)]
        public <#= matrixNameNonGeneric #>(
<# for (int i = 0; i < size; i++) { #>
            <#= tupleName #> row<#= i #><#= i+1<size?",":"" #>
<# } #>
        )
        {
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"V{i}{c}")) #>) = row<#= i #>;
<# } #>
        }

        public static <#= matrixName #> AdditiveIdentity => default;
        public static <#= matrixName #> MultiplicativeIdentity => new(
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Repeat("T.AdditiveIdentity", i).Append("T.MultiplicativeIdentity").Concat(Enumerable.Repeat("T.AdditiveIdentity", size-1-i))) #>)<#= i+1<size?",":");" #>
<# } #>

        [凾(256)] public static <#= matrixName #> operator +(<#= matrixName #> x) => x;
        [凾(256)]
        public static <#= matrixName #> operator -(<#= matrixName #> x)
            => new(
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"x.V{i}{c}")) #>)<#= i+1<size?",":");" #>
<# } #>


        [凾(256)]
        public static <#= matrixName #> operator +(<#= matrixName #> x, <#= matrixName #> y)
            => new(
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"x.V{i}{c} + y.V{i}{c}")) #>)<#= i+1<size?",":");" #>
<# } #>
        [凾(256)]
        public static <#= matrixName #> operator -(<#= matrixName #> x, <#= matrixName #> y)
            => new(
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"x.V{i}{c} - y.V{i}{c}")) #>)<#= i+1<size?",":");" #>
<# } #>

        [凾(256)]
        public static <#= matrixName #> operator *(<#= matrixName #> x, <#= matrixName #> y)
            => new(
<# for (int i = 0; i < size; i++) { #>
            (
<# for (int j = 0; j < size; j++) { #>
                <#= string.Join(" + ", Enumerable.Range(0, size).Select(k => $"x.V{i}{k} * y.V{k}{j}")) #><#= j+1<size?",":"" #>
<# } #>
            )<#= i+1<size?",":"" #>
<# } #>
            );

        [凾(256)]
        public static <#= matrixName #> operator *(<#= matrixName #> m, T x)
            => new(
<# for (int i = 0; i < size; i++) { #>
            (<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"x * m.V{i}{c}")) #>)<#= i+1<size?",":");" #>
<# } #>

        /// <summary>
        /// <#= size #>次元ベクトルにかける
        /// </summary>
        [凾(256)]
        public static <#= tupleName #> operator *(<#= matrixName #> mat, <#= tupleName #> vector) => mat.Multiply(vector);

        /// <summary>
        /// <#= size #>次元ベクトルにかける
        /// </summary>
        [凾(256)]
        public <#= tupleName #> Multiply(<#= tupleName #> vector) => Multiply(<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"vector.Col{c}")) #>);

        /// <summary>
        /// <#= size #>次元ベクトルにかける
        /// </summary>
        [凾(256)]
        public <#= tupleName #> Multiply(<#= string.Join(", ", Enumerable.Range(0, size).Select(c => $"T v{c}")) #>)
                => (
<# for (int i = 0; i < size; i++) { #>
                        <#= string.Join(" + ", Enumerable.Range(0, size).Select(c => $"V{i}{c} * v{c}")) #><#= i+1<size?",":"" #>
<# } #>
                   );

        [凾(256)] public static bool operator ==(<#= matrixName #> left, <#= matrixName #> right) => left.Equals(right);
        [凾(256)] public static bool operator !=(<#= matrixName #> left, <#= matrixName #> right) => !(left == right);
        [凾(256)] public override bool Equals(object obj) => obj is <#= matrixName #> x && Equals(x);

        [凾(256)]
        public bool Equals(<#= matrixName #> other) =>
<#
for (int i = 0; i < size; i++) {
for (int j = 0; j < size; j++) {
#>
            EqualityComparer<T>.Default.Equals(V<#= i #><#= j #>, other.V<#= i #><#= j #>)<#= i+1<size||j+1<size?" &&":";" #>
<# }} #>
        public override int GetHashCode()
        {
            HashCode hash = new();
<#
for (int i = 0; i < size; i++) {
for (int j = 0; j < size; j++) {
#>
            hash.Add(V<#= i #><#= j #>);
<# }} #>
            return hash.ToHashCode();
        }
    }
}
