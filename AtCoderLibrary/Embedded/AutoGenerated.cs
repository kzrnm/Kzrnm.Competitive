using System.Collections.ObjectModel;
using System.ComponentModel;
using System.CodeDom.Compiler;
namespace AtCoder.Embedded
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public class AclFileInfo
    {
        public string FileName { get; }
        public ReadOnlyCollection<string> TypeNames { get; }
        public ReadOnlyCollection<string> Usings { get; }
        public ReadOnlyCollection<string> Dependencies { get; }
        public string CodeBody { get; }
        public AclFileInfo(string fileName, string[] typeNames, string[] usings, string[] dependencies, string code)
        {
            FileName = fileName;
            TypeNames = new ReadOnlyCollection<string>(typeNames);
            Usings = new ReadOnlyCollection<string>(usings);
            Dependencies = new ReadOnlyCollection<string>(dependencies);
            CodeBody = code;
        }
    }
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public static class AutoGenerated__SourceInfo
    {
        public static readonly ReadOnlyCollection<AclFileInfo> FileInfo
            = new ReadOnlyCollection<AclFileInfo>(new AclFileInfo[]
            {
new AclFileInfo(@"Global.cs", new string[] { @"AtCoder.Global" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;", @"using System.Numerics;" }, new string[] { @"Extensions.cs" }, @"namespace AtCoder { public static class Global { public static int Gcd(params int[] nums) { var gcd = nums[0]; for (var i = 1; i < nums.Length; i++) gcd = Gcd(nums[i], gcd); return gcd; } public static int Gcd(int a, int b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b)); public static int Lcm(int a, int b) => a / Gcd(a, b) * b; public static int Lcm(params int[] nums) { var lcm = nums[0]; for (var i = 1; i < nums.Length; i++) lcm = Lcm(lcm, nums[i]); return lcm; } public static long Gcd(params long[] nums) { var gcd = nums[0]; for (var i = 1; i < nums.Length; i++) gcd = Gcd(nums[i], gcd); return gcd; } public static long Gcd(long a, long b) => b > a ? Gcd(b, a) : (b == 0 ? a : Gcd(b, a % b)); public static long Lcm(long a, long b) => a / Gcd(a, b) * b; public static long Lcm(params long[] nums) { var lcm = nums[0]; for (var i = 1; i < nums.Length; i++) lcm = Lcm(lcm, nums[i]); return lcm; } public static T[] NewArray<T>(int len0, T value) => new T[len0].Fill(value); public static T[] NewArray<T>(int len0, Func<T> factory) { var arr = new T[len0]; for (int i = 0; i < arr.Length; i++) arr[i] = factory(); return arr; } public static T[][] NewArray<T>(int len0, int len1, T value) where T : struct { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, value); return arr; } public static T[][] NewArray<T>(int len0, int len1, Func<T> factory) { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, factory); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, T value) where T : struct { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, value); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, Func<T> factory) { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, factory); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, T value) where T : struct { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, value); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, Func<T> factory) { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, factory); return arr; } public static long Pow(long x, int y) { long res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static BigInteger ParseBigInteger(ReadOnlySpan<char> s) { if (s[0] == '-') return -ParseBigInteger(s[1..]); BigInteger res; if (s.Length % 9 == 0) res = 0; else { res = new BigInteger(int.Parse(s.Slice(0, s.Length % 9))); s = s.Slice(s.Length % 9); } while (s.Length > 0) { var sp = s.Slice(0, 9); res *= 1000_000_000; res += int.Parse(sp); s = s.Slice(9); } return res; } public static int PopCount(int x) => BitOperations.PopCount((uint)x); public static int PopCount(long x) => BitOperations.PopCount((ulong)x); public static int PopCount(ulong x) => BitOperations.PopCount(x); public static int MSB(int x) => BitOperations.Log2((uint)x); public static int MSB(uint x) => BitOperations.Log2(x); public static int MSB(long x) => BitOperations.Log2((ulong)x); public static int MSB(ulong x) => BitOperations.Log2(x); public static int LSB(int x) => BitOperations.TrailingZeroCount((uint)x); public static int LSB(uint x) => BitOperations.TrailingZeroCount(x); public static int LSB(long x) => BitOperations.TrailingZeroCount((ulong)x); public static int LSB(ulong x) => BitOperations.TrailingZeroCount(x); public static Dictionary<T, int> Compress<T>(IEnumerable<T> orig) where T : IComparable<T> => Compress(orig, Comparer<T>.Default); public static Dictionary<T, int> Compress<T>(IEnumerable<T> orig, IComparer<T> comparer) { var ox = new HashSet<T>(orig).ToArray(); Array.Sort(ox, comparer); var zip = new Dictionary<T, int>(); for (int i = 0; i < ox.Length; i++) zip[ox[i]] = i; return zip; } public static int[] Compressed<T>(T[] orig) where T : IComparable<T> { static int[] Compressed(T[] orig, Dictionary<T, int> zip) { var res = new int[orig.Length]; for (int i = 0; i < res.Length; i++) res[i] = zip[orig[i]]; return res; } return Compressed(orig, Compress(orig)); } public static IEnumerable<T[]> NextPermutation<T>(IEnumerable<T> orig) where T : IComparable<T> { var arr = orig.ToArray(); while (true) { yield return arr; int i; for (i = arr.Length - 2; i >= 0; i--) if (arr[i].CompareTo(arr[i + 1]) < 0) break; if (i < 0) break; int j; for (j = arr.Length - 1; j >= 0; j--) if (arr[i].CompareTo(arr[j]) < 0) break; (arr[i], arr[j]) = (arr[j], arr[i]); Array.Reverse(arr, i + 1, arr.Length - i - 1); } } } } "),
new AclFileInfo(@"Extensions.cs", new string[] { @"AtCoder.Extensions" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;", @"using System.Linq.Expressions;", @"using System.Runtime.CompilerServices;" }, new string[] { @"ExComparer.cs" }, @"namespace AtCoder { public static class Extensions { public static bool UpdateMax<T>(this ref T r, T val) where T : struct, IComparable<T> { if (r.CompareTo(val) < 0) { r = val; return true; } return false; } public static bool UpdateMin<T>(this ref T r, T val) where T : struct, IComparable<T> { if (r.CompareTo(val) > 0) { r = val; return true; } return false; } public static T[] Fill<T>(this T[] arr, T value) { Array.Fill(arr, value); return arr; } public static T[] Sort<T>(this T[] arr) { Array.Sort(arr); return arr; } public static string[] Sort(this string[] arr) => Sort(arr, StringComparer.Ordinal); public static T[] Sort<T, U>(this T[] arr, Expression<Func<T, U>> selector) where U : IComparable<U> => Sort(arr, ExComparer<T>.CreateExp(selector)); public static T[] Sort<T>(this T[] arr, Comparison<T> comparison) { Array.Sort(arr, comparison); return arr; } public static T[] Sort<T>(this T[] arr, IComparer<T> comparer) { Array.Sort(arr, comparer); return arr; } public static T[] Reverse<T>(this T[] arr) { Array.Reverse(arr); return arr; } public static (int index, T max) MaxBy<T>(this T[] arr) where T : IComparable<T> { T max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { if (max.CompareTo(arr[i]) < 0) { max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (int index, T max) MaxBy<T, TMax>(this T[] arr, Func<T, TMax> maxBySelector) where TMax : IComparable<TMax> { var maxItem = maxBySelector(arr[0]); var max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { var nx = maxBySelector(arr[i]); if (maxItem.CompareTo(nx) < 0) { maxItem = nx; max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (TSource item, TMax max) MaxBy<TSource, TMax> (this IEnumerable<TSource> source, Func<TSource, TMax> maxBySelector) where TMax : IComparable<TMax> { TMax max; TSource maxByItem; var e = source.GetEnumerator(); e.MoveNext(); maxByItem = e.Current; max = maxBySelector(maxByItem); while (e.MoveNext()) { var item = e.Current; var next = maxBySelector(item); if (max.CompareTo(next) < 0) { max = next; maxByItem = item; } } return (maxByItem, max); } public static (int index, T min) MinBy<T>(this T[] arr) where T : IComparable<T> { T min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { if (min.CompareTo(arr[i]) > 0) { min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (int index, T min) MinBy<T, TMin>(this T[] arr, Func<T, TMin> minBySelector) where TMin : IComparable<TMin> { var minItem = minBySelector(arr[0]); var min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { var nx = minBySelector(arr[i]); if (minItem.CompareTo(nx) > 0) { minItem = nx; min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (TSource item, TMin min) MinBy<TSource, TMin> (this IEnumerable<TSource> source, Func<TSource, TMin> minBySelector) where TMin : IComparable<TMin> { TMin min; TSource minByItem; var e = source.GetEnumerator(); e.MoveNext(); minByItem = e.Current; min = minBySelector(minByItem); while (e.MoveNext()) { var item = e.Current; var next = minBySelector(item); if (min.CompareTo(next) > 0) { min = next; minByItem = item; } } return (minByItem, min); } public static Dictionary<TKey, int> GroupCount<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.Count()); public static Dictionary<TKey, int> GroupCount<TKey>(this IEnumerable<TKey> source) => source.GroupCount(i => i); public static Span<T> AsSpan<T>(this List<T> list, int start = 0) => Unsafe.As<Tuple<T[]>>(list).Item1.AsSpan(start, list.Count); public static ref T Get<T>(this T[] arr, int index) { if (index < 0) return ref arr[arr.Length + index]; return ref arr[index]; } public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key) { dic.TryGetValue(key, out var v); return v; } } } "),
new AclFileInfo(@"ExComparer.cs", new string[] { @"AtCoder.ExComparer<T>", @"AtCoder.ExComparer<T>.ExpressionComparer<K>", @"AtCoder.ExComparer<T>.ExpressionComparer<K>.ParameterReplaceVisitor", @"AtCoder.ExComparer<T>.ReverseComparer" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq.Expressions;" }, new string[] {  }, @"namespace AtCoder { public static class ExComparer<T> { class ExpressionComparer<K> : IComparer<T> where K : IComparable<K> { private class ParameterReplaceVisitor : ExpressionVisitor { private readonly ParameterExpression from; private readonly ParameterExpression to; public ParameterReplaceVisitor(ParameterExpression from, ParameterExpression to) { this.from = from; this.to = to; } protected override Expression VisitParameter(ParameterExpression node) => node == from ? to : base.VisitParameter(node); } readonly Comparison<T> func; public ExpressionComparer(Expression<Func<T, K>> expression) { var paramA = expression.Parameters[0]; var paramB = Expression.Parameter(typeof(T)); var f2 = (Expression<Func<T, K>>)new ParameterReplaceVisitor(expression.Parameters[0], paramB).Visit(expression); var compExp = Expression.Lambda<Comparison<T>>(Expression.Call( expression.Body, typeof(K).GetMethod(nameof(IComparable<K>.CompareTo), new[] { typeof(K) }), f2.Body), paramA, paramB); this.func = compExp.Compile(); } public int Compare(T x, T y) => func(x, y); public override bool Equals(object obj) => obj is ExpressionComparer<K> c && this.func == c.func; public override int GetHashCode() => func.GetHashCode(); } class ReverseComparer : IComparer<T> { private static readonly Comparer<T> orig = Comparer<T>.Default; public int Compare(T y, T x) => orig.Compare(x, y); public override bool Equals(object obj) => obj is ReverseComparer; public override int GetHashCode() => GetType().GetHashCode(); } public static IComparer<T> CreateExp<K>(Expression<Func<T, K>> expression) where K : IComparable<K> => new ExpressionComparer<K>(expression); public static readonly IComparer<T> DefaultReverse = new ReverseComparer(); } } "),
new AclFileInfo(@"BinarySearchExtension.cs", new string[] { @"AtCoder.BinarySearchExtension" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder { public static class BinarySearchExtension { public static int BinarySearch(int ok, int ng, Predicate<int> Ok) { while (Math.Abs(ok - ng) > 1) { var m = (ok + ng) >> 1; if (Ok(m)) ok = m; else ng = m; } return ok; } public static int LowerBound<T>(this T[] a, T v, IComparer<T> cmp) => BinarySearch(a.AsSpan(), v, cmp, true); public static int LowerBound<T>(this T[] a, T v) => BinarySearch(a.AsSpan(), v, Comparer<T>.Default, true); public static int UpperBound<T>(this T[] a, T v, IComparer<T> cmp) => BinarySearch(a.AsSpan(), v, cmp, false); public static int UpperBound<T>(this T[] a, T v) => BinarySearch(a.AsSpan(), v, Comparer<T>.Default, false); public static int LowerBound<T>(this IList<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this IList<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this IList<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this IList<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); public static int LowerBound<T>(this Span<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this Span<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this Span<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this Span<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); public static int LowerBound<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this ReadOnlySpan<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this ReadOnlySpan<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); static int BinarySearch<T>(this IList<T> a, T v, IComparer<T> cmp, bool isLowerBound) { int ok = a.Count; int ng = -1; while (ok - ng > 1) { var m = (ok + ng) >> 1; var c = cmp.Compare(a[m], v); if (c > 0 || (c == 0 && isLowerBound)) ok = m; else ng = m; } return ok; } static int BinarySearch<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp, bool isLowerBound) { int ok = a.Length; int ng = -1; while (ok - ng > 1) { var m = (ok + ng) >> 1; var c = cmp.Compare(a[m], v); if (c > 0 || (c == 0 && isLowerBound)) ok = m; else ng = m; } return ok; } } } "),
new AclFileInfo(@"Collection/Set.cs", new string[] { @"AtCoder.Collection.Set<T>", @"AtCoder.Collection.Set<T>.Enumerator", @"AtCoder.Collection.Set<T>.Node" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs" }, @"namespace AtCoder.Collection { [DebuggerTypeProxy(typeof(CollectionDebugView<>))] [DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class Set<T> : ICollection<T>, IReadOnlyCollection<T> { internal const string LISENCE = @""
Original is SortedSet<T>

Copyright (c) .NET Foundation and Contributors
Released under the MIT license
https://github.com/dotnet/runtime/blob/master/LICENSE.TXT
""; public bool IsMulti { get; } public T Min { get { if (root == null) return default; var cur = root; while (cur.Left != null) { cur = cur.Left; } return cur.Item; } } public T Max { get { if (root == null) return default; var cur = root; while (cur.Right != null) { cur = cur.Right; } return cur.Item; } } public Node FindNode(T item) { Node current = root; while (current != null) { int order = comparer.Compare(item, current.Item); if (order == 0) return current; current = order < 0 ? current.Left : current.Right; } return null; } public int Index(Node node) { var ret = NodeSize(node.Left); Node prev = node; node = node.Parent; while (prev != root) { if (node.Left != prev) { ret += NodeSize(node.Left) + 1; } prev = node; node = node.Parent; } return ret; } public Node FindByIndex(int index) { var current = root; var currentIndex = current.Size - NodeSize(current.Right) - 1; while (currentIndex != index) { if (currentIndex > index) { current = current.Left; if (current == null) break; currentIndex -= NodeSize(current.Right) + 1; } else { current = current.Right; if (current == null) break; currentIndex += NodeSize(current.Left) + 1; } } return current; } public (Node node, int index) BinarySearch(T item, bool isLowerBound) { Node right = null; Node current = root; if (current == null) return (null, -1); int ri = -1; int ci = NodeSize(current.Left); while (true) { var order = comparer.Compare(item, current.Item); if (order < 0 || (isLowerBound && order == 0)) { right = current; ri = ci; current = current.Left; if (current != null) ci -= NodeSize(current.Right) + 1; else break; } else { current = current.Right; if (current != null) ci += NodeSize(current.Left) + 1; else break; } } return (right, ri); } public Node FindNodeLowerBound(T item) => BinarySearch(item, true).node; public Node FindNodeUpperBound(T item) => BinarySearch(item, false).node; public T LowerBoundItem(T item) => BinarySearch(item, true).node.Item; public T UpperBoundItem(T item) => BinarySearch(item, false).node.Item; public int LowerBoundIndex(T item) => BinarySearch(item, true).index; public int UpperBoundIndex(T item) => BinarySearch(item, false).index; public IEnumerable<T> Reversed() { var e = new Enumerator(this, true, null); while (e.MoveNext()) yield return e.Current; } public IEnumerable<T> Enumerate(Node from) => Enumerate(from, false); public IEnumerable<T> Enumerate(Node from, bool reverse) { if (from == null) yield break; var e = new Enumerator(this, reverse, from); while (e.MoveNext()) yield return e.Current; } public Set(bool isMulti = false) : this(Comparer<T>.Default, isMulti) { } public Set(IEnumerable<T> collection, bool isMulti = false) : this(collection, Comparer<T>.Default, isMulti) { } public Set(IComparer<T> comparer, bool isMulti = false) { this.comparer = comparer; this.IsMulti = isMulti; } public Set(IEnumerable<T> collection, IComparer<T> comparer, bool isMulti = false) { this.comparer = comparer; var arr = InitArray(collection); this.root = ConstructRootFromSortedArray(arr, 0, arr.Length - 1, null); this.IsMulti = isMulti; } protected T[] InitArray(IEnumerable<T> collection) { T[] arr; if (this.IsMulti) { arr = collection.ToArray(); Array.Sort(arr, this.comparer); } else { var list = new List<T>(collection); list.Sort(this.comparer); for (int i = list.Count - 1; i > 0; i--) if (this.comparer.Compare(list[i - 1], list[i]) == 0) list.RemoveAt(i); arr = list.ToArray(); } return arr; } public int Count => NodeSize(root); protected static int NodeSize(Node node) => node == null ? 0 : node.Size; protected readonly IComparer<T> comparer; bool ICollection<T>.IsReadOnly => false; Node root; static Node ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node redNode) { int size = endIndex - startIndex + 1; Node root; switch (size) { case 0: return null; case 1: root = new Node(arr[startIndex], false); if (redNode != null) { root.Left = redNode; } break; case 2: root = new Node(arr[startIndex], false) { Right = new Node(arr[endIndex], true) }; if (redNode != null) { root.Left = redNode; } break; case 3: root = new Node(arr[startIndex + 1], false) { Left = new Node(arr[startIndex], false), Right = new Node(arr[endIndex], false) }; if (redNode != null) { root.Left.Left = redNode; } break; default: int midpt = ((startIndex + endIndex) / 2); root = new Node(arr[midpt], false) { Left = ConstructRootFromSortedArray(arr, startIndex, midpt - 1, redNode), Right = size % 2 == 0 ? ConstructRootFromSortedArray(arr, midpt + 2, endIndex, new Node(arr[midpt + 1], true)) : ConstructRootFromSortedArray(arr, midpt + 1, endIndex, null) }; break; } return root; } void ICollection<T>.Add(T item) => this.Add(item); public bool Add(T item) { if (root == null) { root = new Node(item, false); return true; } Node current = root; Node parent = null; Node grandParent = null; Node greatGrandParent = null; int order = 0; while (current != null) { order = comparer.Compare(item, current.Item); if (order == 0 && !this.IsMulti) { current.Item = item; root.IsRed = false; return false; } if (Is4Node(current)) { Split4Node(current); if (IsNonNullRed(parent) == true) { InsertionBalance(current, ref parent, grandParent, greatGrandParent); } } greatGrandParent = grandParent; grandParent = parent; parent = current; current = (order < 0) ? current.Left : current.Right; } Node node = new Node(item, true); if (order >= 0) parent.Right = node; else parent.Left = node; if (parent.IsRed) InsertionBalance(node, ref parent, grandParent, greatGrandParent); root.IsRed = false; return true; } public bool Remove(T item) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(item, current.Item); if (order == 0) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } public void Clear() { root = null; } public bool Contains(T item) => FindNode(item) != null; public void CopyTo(T[] array, int arrayIndex) { foreach (var item in this) array[arrayIndex++] = item; } public Enumerator GetEnumerator() => new Enumerator(this); IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this); System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => new Enumerator(this); static bool Is2Node(Node node) => IsNonNullBlack(node) && IsNullOrBlack(node.Left) && IsNullOrBlack(node.Right); static bool Is4Node(Node node) => IsNonNullRed(node.Left) && IsNonNullRed(node.Right); static bool IsNonNullRed(Node node) => node != null && node.IsRed; static bool IsNonNullBlack(Node node) => node != null && !node.IsRed; static bool IsNullOrBlack(Node node) => node == null || !node.IsRed; void ReplaceNode(Node match, Node parentOfMatch, Node succesor, Node parentOfSuccesor) { if (succesor == match) { succesor = match.Left; } else { if (succesor.Right != null) { succesor.Right.IsRed = false; } if (parentOfSuccesor != match) { parentOfSuccesor.Left = succesor.Right; succesor.Right = match.Right; } succesor.Left = match.Left; } if (succesor != null) { succesor.IsRed = match.IsRed; } ReplaceChildOrRoot(parentOfMatch, match, succesor); } static void Merge2Nodes(Node parent) { parent.IsRed = false; parent.Left.IsRed = true; parent.Right.IsRed = true; } static void Split4Node(Node node) { node.IsRed = true; node.Left.IsRed = false; node.Right.IsRed = false; } static Node GetSibling(Node node, Node parent) { return parent.Left == node ? parent.Right : parent.Left; } void InsertionBalance(Node current, ref Node parent, Node grandParent, Node greatGrandParent) { bool parentIsOnRight = grandParent.Right == parent; bool currentIsOnRight = parent.Right == current; Node newChildOfGreatGrandParent; if (parentIsOnRight == currentIsOnRight) { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeft(grandParent) : RotateRight(grandParent); } else { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeftRight(grandParent) : RotateRightLeft(grandParent); parent = greatGrandParent; } grandParent.IsRed = true; newChildOfGreatGrandParent.IsRed = false; ReplaceChildOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent); } static Node Rotate(Node node, TreeRotation rotation) { switch (rotation) { case TreeRotation.Right: node.Left.Left.IsRed = false; return RotateRight(node); case TreeRotation.Left: node.Right.Right.IsRed = false; return RotateLeft(node); case TreeRotation.RightLeft: return RotateRightLeft(node); case TreeRotation.LeftRight: return RotateLeftRight(node); default: throw new InvalidOperationException(); } } static Node RotateLeft(Node node) { Node child = node.Right; node.Right = child.Left; child.Left = node; return child; } static Node RotateLeftRight(Node node) { Node child = node.Left; Node grandChild = child.Right; node.Left = grandChild.Right; grandChild.Right = node; child.Right = grandChild.Left; grandChild.Left = child; return grandChild; } static Node RotateRight(Node node) { Node child = node.Left; node.Left = child.Right; child.Right = node; return child; } static Node RotateRightLeft(Node node) { Node child = node.Right; Node grandChild = child.Left; node.Right = grandChild.Left; grandChild.Left = node; child.Left = grandChild.Right; grandChild.Right = child; return grandChild; } void ReplaceChildOrRoot(Node parent, Node child, Node newChild) { if (parent != null) { if (parent.Left == child) { parent.Left = newChild; } else { parent.Right = newChild; } } else { root = newChild; } } static TreeRotation GetRotation(Node parent, Node current, Node sibling) { if (IsNonNullRed(sibling.Left)) { if (parent.Left == current) { return TreeRotation.RightLeft; } return TreeRotation.Right; } else { if (parent.Left == current) { return TreeRotation.Left; } return TreeRotation.LeftRight; } } public struct Enumerator : IEnumerator<T> { readonly Set<T> tree; readonly Stack<Node> stack; Node current; readonly bool reverse; internal Enumerator(Set<T> set) : this(set, false, null) { } internal Enumerator(Set<T> set, bool reverse, Node startNode) { tree = set; stack = new Stack<Node>(2 * Log2(tree.Count + 1)); current = null; this.reverse = reverse; if (startNode == null) IntializeAll(); else Intialize(startNode); } void IntializeAll() { var node = tree.root; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } } void Intialize(Node startNode) { if (startNode == null) throw new InvalidOperationException(nameof(startNode) + ""is null""); current = null; var node = startNode; var list = new List<Node>(Log2(tree.Count + 1)); var comparer = tree.comparer; if (reverse) { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Item, node.Item) >= 0) list.Add(node); node = node.Parent; } } else { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Item, node.Item) <= 0) list.Add(node); node = node.Parent; } } list.Reverse(); foreach (var n in list) stack.Push(n); } [MethodImpl(MethodImplOptions.AggressiveInlining)] static int Log2(int num) => BitOperations.Log2((uint)num) + 1; public T Current => current == null ? default : current.Item; public bool MoveNext() { if (stack.Count == 0) { current = null; return false; } current = stack.Pop(); var node = reverse ? current.Left : current.Right; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } return true; } object System.Collections.IEnumerator.Current => this.Current; public void Dispose() { } public void Reset() => throw new NotSupportedException(); } public class Node { public bool IsRed; public T Item; public Node Parent { get; private set; } Node _left; public Node Left { get { return _left; } set { _left = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } Node _right; public Node Right { get { return _right; } set { _right = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } public int Size { get; private set; } = 1; public Node(T item, bool isRed) { this.Item = item; this.IsRed = isRed; } public bool UpdateSize() { var oldsize = this.Size; var size = 1; if (Left != null) size += Left.Size; if (Right != null) size += Right.Size; this.Size = size; return oldsize != size; } public override string ToString() => $""Size = {Size}, Item = {Item}""; } enum TreeRotation : byte { Left = 1, Right = 2, RightLeft = 3, LeftRight = 4, } } } "),
new AclFileInfo(@"Collection/PriorityQueue.cs", new string[] { @"AtCoder.Collection.PriorityQueue<T>", @"AtCoder.Collection.PriorityQueue<TKey, TValue>", @"AtCoder.Collection.PriorityQueue<TKey, TValue>.KeyComparer" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.Collection { [System.Diagnostics.DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class PriorityQueue<T> { protected readonly List<T> data; protected readonly IComparer<T> comparer; public PriorityQueue() : this(Comparer<T>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<T>.Default) { } public PriorityQueue(IComparer<T> comparer) { this.data = new List<T>(); this.comparer = comparer; } public PriorityQueue(int capacity, IComparer<T> comparer) { this.data = new List<T>(capacity); this.comparer = comparer; } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public int Count => data.Count; public T Peek => data[0]; public void Add(T value) { data.Add(value); UpdateUp(data.Count - 1); } public T Dequeue() { var res = data[0]; data[0] = data[^1]; data.RemoveAt(data.Count - 1); UpdateDown(0); return res; } void UpdateUp(int i) { if (i > 0) { var p = (i - 1) >> 1; if (comparer.Compare(data[i], data[p]) < 0) { (data[p], data[i]) = (data[i], data[p]); UpdateUp(p); } } } void UpdateDown(int i) { var n = data.Count; var child = 2 * i + 1; if (child < n) { if (child != n - 1 && comparer.Compare(data[child], data[child + 1]) > 0) child++; if (comparer.Compare(data[i], data[child]) > 0) { (data[child], data[i]) = (data[i], data[child]); UpdateDown(child); } } } public void Clear() => data.Clear(); [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.RootHidden)] T[] Items { get { var arr = data.ToArray(); Array.Sort(arr, comparer); return arr; } } } public class PriorityQueue<TKey, TValue> : PriorityQueue<KeyValuePair<TKey, TValue>> { class KeyComparer : IComparer<KeyValuePair<TKey, TValue>> { public readonly IComparer<TKey> comparer; public KeyComparer(IComparer<TKey> comparer) { this.comparer = comparer; } public int Compare(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y) => comparer.Compare(x.Key, y.Key); } public PriorityQueue() : this(Comparer<TKey>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<TKey>.Default) { } public PriorityQueue(IComparer<TKey> comparer) : base(new KeyComparer(comparer)) { } public PriorityQueue(int capacity, IComparer<TKey> comparer) : base(capacity, new KeyComparer(comparer)) { } public void Add(TKey key, TValue value) => Add(new KeyValuePair<TKey, TValue>(key, value)); } } "),
new AclFileInfo(@"Collection/Deque.cs", new string[] { @"AtCoder.Collection.Deque<T>", @"AtCoder.Collection.Deque<T>.Enumerator" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using AtCoder.Internal;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs", @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder.Collection { [System.Diagnostics.DebuggerTypeProxy(typeof(CollectionDebugView<>))] [System.Diagnostics.DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] class Deque<T> : IEnumerable<T>, IReadOnlyCollection<T>, ICollection<T> { T[] data; int mask; int head; int tail; public Deque() : this(8) { } public Deque(int capacity) { if (capacity <= 8) capacity = 8; else capacity = 1 << (InternalBit.CeilPow2(capacity)); data = new T[capacity]; mask = capacity - 1; } public int Count => (tail - head) & mask; public T this[int i] => data[(head + i) & mask]; public T First => data[head]; public T Last => data[(tail - 1) & mask]; public T PopFirst() { if (head == tail) throw new InvalidOperationException(""deque is empty""); var item = data[head]; head = (head + 1) & mask; return item; } public T PopLast() { if (head == tail) throw new InvalidOperationException(""deque is empty""); return data[tail = (tail - 1) & mask]; } public void AddFirst(T item) { data[head = (head - 1) & mask] = item; if (head == tail) Expand(); } public void AddLast(T item) { data[tail] = item; tail = (tail + 1) & mask; if (head == tail) Expand(); } void Expand() { var oldSize = data.Length; var newArray = new T[oldSize << 1]; var hsize = oldSize - head; Array.Copy(data, head, newArray, 0, hsize); Array.Copy(data, 0, newArray, hsize, tail); data = newArray; mask = data.Length - 1; head = 0; tail = oldSize; } public void Add(T item) => AddLast(item); bool ICollection<T>.IsReadOnly => false; void ICollection<T>.Clear() => head = tail = 0; bool ICollection<T>.Contains(T item) { if (head == tail) return false; if (head < tail) { var ix = Array.IndexOf(data, item); return ix >= 0 && ix < tail; } else { var ix = Array.IndexOf(data, item, head); if (ix >= 0) return true; ix = Array.IndexOf(data, item); return ix >= 0 && ix < tail; } } void ICollection<T>.CopyTo(T[] array, int arrayIndex) { if (head <= tail) { Array.Copy(data, head, array, arrayIndex, tail - head); } else { var hsize = data.Length - head; Array.Copy(data, head, array, arrayIndex, hsize); Array.Copy(data, 0, array, arrayIndex + hsize, tail); } } public IEnumerable<T> Reversed() { Enumerator e = new Enumerator(this, true); while (e.MoveNext()) yield return e.Current; } public bool Remove(T item) { throw new NotSupportedException(); } public Enumerator GetEnumerator() => new Enumerator(this, false); IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator(); IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); public struct Enumerator : IEnumerator<T>, IEnumerator { readonly Deque<T> deque; readonly bool isReverse; int index; public readonly int last; public T Current => deque.data[index]; public Enumerator(Deque<T> deque, bool isReverse) { this.deque = deque; this.isReverse = isReverse; if (isReverse) { index = deque.tail + 1; last = deque.head; } else { index = deque.head - 1; last = (deque.tail - 1) & deque.mask; } } object IEnumerator.Current => Current; public bool MoveNext() { if (index == last) return false; if (isReverse) --index; else ++index; index &= deque.mask; return true; } public void Reset() { throw new NotSupportedException(); } public void Dispose() { } } } } "),
new AclFileInfo(@"Collection/SetDictionary.cs", new string[] { @"AtCoder.Collection.SetDictionary<TKey, TValue>", @"AtCoder.Collection.SetDictionary<TKey, TValue>.Enumerator", @"AtCoder.Collection.SetDictionary<TKey, TValue>.Node" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs" }, @"namespace AtCoder.Collection { [DebuggerTypeProxy(typeof(CollectionDebugView<>))] [DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class SetDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue> { internal const string LISENCE = @""
Original is SortedSet<T>

Copyright (c) .NET Foundation and Contributors
Released under the MIT license
https://github.com/dotnet/runtime/blob/master/LICENSE.TXT
""; public bool IsMulti { get; } public KeyValuePair<TKey, TValue> Min { get { if (root == null) return default; var cur = root; while (cur.Left != null) { cur = cur.Left; } return cur.Pair; } } public KeyValuePair<TKey, TValue> Max { get { if (root == null) return default; var cur = root; while (cur.Right != null) { cur = cur.Right; } return cur.Pair; } } public Node FindNode(TKey key) { Node current = root; while (current != null) { int order = comparer.Compare(key, current.Key); if (order == 0) return current; current = order < 0 ? current.Left : current.Right; } return null; } public int Index(Node node) { var ret = NodeSize(node.Left); Node prev = node; node = node.Parent; while (prev != root) { if (node.Left != prev) { ret += NodeSize(node.Left) + 1; } prev = node; node = node.Parent; } return ret; } public Node FindByIndex(int index) { var current = root; var currentIndex = current.Size - NodeSize(current.Right) - 1; while (currentIndex != index) { if (currentIndex > index) { current = current.Left; if (current == null) break; currentIndex -= NodeSize(current.Right) + 1; } else { current = current.Right; if (current == null) break; currentIndex += NodeSize(current.Left) + 1; } } return current; } public (Node node, int index) BinarySearch(TKey key, bool isLowerBound) { Node right = null; Node current = root; if (current == null) return (null, -1); int ri = -1; int ci = NodeSize(current.Left); while (true) { var order = comparer.Compare(key, current.Key); if (order < 0 || (isLowerBound && order == 0)) { right = current; ri = ci; current = current.Left; if (current != null) ci -= NodeSize(current.Right) + 1; else break; } else { current = current.Right; if (current != null) ci += NodeSize(current.Left) + 1; else break; } } return (right, ri); } public Node FindNodeLowerBound(TKey key) => BinarySearch(key, true).node; public Node FindNodeUpperBound(TKey key) => BinarySearch(key, false).node; public KeyValuePair<TKey, TValue> LowerBoundItem(TKey key) => BinarySearch(key, true).node.Pair; public KeyValuePair<TKey, TValue> UpperBoundItem(TKey key) => BinarySearch(key, false).node.Pair; public int LowerBoundIndex(TKey key) => BinarySearch(key, true).index; public int UpperBoundIndex(TKey key) => BinarySearch(key, false).index; public IEnumerable<KeyValuePair<TKey, TValue>> Reversed() { var e = new Enumerator(this, true, null); while (e.MoveNext()) yield return e.Current; } public IEnumerable<KeyValuePair<TKey, TValue>> Enumerate(Node from) => Enumerate(from, false); public IEnumerable<KeyValuePair<TKey, TValue>> Enumerate(Node from, bool reverse) { if (from == null) yield break; var e = new Enumerator(this, reverse, from); while (e.MoveNext()) yield return e.Current; } public SetDictionary(bool isMulti = false) : this(Comparer<TKey>.Default, isMulti) { } public SetDictionary(IDictionary<TKey, TValue> dict, bool isMulti = false) : this(dict, Comparer<TKey>.Default, isMulti) { } public SetDictionary(IComparer<TKey> comparer, bool isMulti = false) { this.comparer = comparer; IsMulti = isMulti; } public SetDictionary(IDictionary<TKey, TValue> dict, IComparer<TKey> comparer, bool isMulti = false) { this.comparer = comparer; var arr = InitArray(dict); root = ConstructRootFromSortedArray(arr, 0, arr.Length - 1, null); IsMulti = isMulti; } protected KeyValuePair<TKey, TValue>[] InitArray(IEnumerable<KeyValuePair<TKey, TValue>> collection) { var comparer = Comparer<KeyValuePair<TKey, TValue>>.Create((a, b) => this.comparer.Compare(a.Key, b.Key)); KeyValuePair<TKey, TValue>[] arr; if (IsMulti) { arr = collection.ToArray(); Array.Sort(arr, comparer); } else { var list = new List<KeyValuePair<TKey, TValue>>(collection); list.Sort(comparer); for (int i = list.Count - 1; i > 0; i--) if (this.comparer.Compare(list[i - 1].Key, list[i].Key) == 0) list.RemoveAt(i); arr = list.ToArray(); } return arr; } public int Count => NodeSize(root); protected static int NodeSize(Node node) => node == null ? 0 : node.Size; protected readonly IComparer<TKey> comparer; bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly => false; ICollection<TKey> IDictionary<TKey, TValue>.Keys => throw new NotSupportedException(); ICollection<TValue> IDictionary<TKey, TValue>.Values => throw new NotSupportedException(); IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => throw new NotSupportedException(); IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => throw new NotSupportedException(); public TValue this[TKey key] { get => throw new NotSupportedException(); set => throw new NotSupportedException(); } Node root; static Node ConstructRootFromSortedArray(KeyValuePair<TKey, TValue>[] arr, int startIndex, int endIndex, Node redNode) { int size = endIndex - startIndex + 1; Node root; switch (size) { case 0: return null; case 1: root = new Node(arr[startIndex], false); if (redNode != null) { root.Left = redNode; } break; case 2: root = new Node(arr[startIndex], false) { Right = new Node(arr[endIndex], true) }; if (redNode != null) { root.Left = redNode; } break; case 3: root = new Node(arr[startIndex + 1], false) { Left = new Node(arr[startIndex], false), Right = new Node(arr[endIndex], false) }; if (redNode != null) { root.Left.Left = redNode; } break; default: int midpt = ((startIndex + endIndex) / 2); root = new Node(arr[midpt], false) { Left = ConstructRootFromSortedArray(arr, startIndex, midpt - 1, redNode), Right = size % 2 == 0 ? ConstructRootFromSortedArray(arr, midpt + 2, endIndex, new Node(arr[midpt + 1], true)) : ConstructRootFromSortedArray(arr, midpt + 1, endIndex, null) }; break; } return root; } void IDictionary<TKey, TValue>.Add(TKey key, TValue value) => Add(key, value); void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> pair) => Add(pair.Key, pair.Value); public bool Add(TKey key, TValue value) { if (root == null) { root = new Node(key, value, false); return true; } Node current = root; Node parent = null; Node grandParent = null; Node greatGrandParent = null; int order = 0; while (current != null) { order = comparer.Compare(key, current.Key); if (order == 0 && !IsMulti) { current.Key = key; root.IsRed = false; return false; } if (Is4Node(current)) { Split4Node(current); if (IsNonNullRed(parent) == true) { InsertionBalance(current, ref parent, grandParent, greatGrandParent); } } greatGrandParent = grandParent; grandParent = parent; parent = current; current = (order < 0) ? current.Left : current.Right; } Node node = new Node(key, value, true); if (order >= 0) parent.Right = node; else parent.Left = node; if (parent.IsRed) InsertionBalance(node, ref parent, grandParent, greatGrandParent); root.IsRed = false; return true; } public bool Remove(TKey key) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(key, current.Key); if (order == 0) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> pair) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(pair.Key, current.Key); if (order == 0 && EqualityComparer<TValue>.Default.Equals(pair.Value, current.Value)) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } public void Clear() { root = null; } public bool ContainsKey(TKey key) => FindNode(key) != null; bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> pair) { var node = FindNodeLowerBound(pair.Key); if (node == null) return false; var e = new Enumerator(this, false, node); while (e.MoveNext()) { if (comparer.Compare(pair.Key, e.Current.Key) != 0) break; if (EqualityComparer<TValue>.Default.Equals(pair.Value, e.Current.Value)) return true; } return false; } public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) { foreach (var item in this) array[arrayIndex++] = item; } public bool TryGetValue(TKey key, out TValue value) { var node = FindNode(key); if (node == null) { value = default; return false; } value = node.Value; return true; } public Enumerator GetEnumerator() => new Enumerator(this); IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator() => new Enumerator(this); IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this); static bool Is2Node(Node node) => IsNonNullBlack(node) && IsNullOrBlack(node.Left) && IsNullOrBlack(node.Right); static bool Is4Node(Node node) => IsNonNullRed(node.Left) && IsNonNullRed(node.Right); static bool IsNonNullRed(Node node) => node != null && node.IsRed; static bool IsNonNullBlack(Node node) => node != null && !node.IsRed; static bool IsNullOrBlack(Node node) => node == null || !node.IsRed; void ReplaceNode(Node match, Node parentOfMatch, Node succesor, Node parentOfSuccesor) { if (succesor == match) { succesor = match.Left; } else { if (succesor.Right != null) { succesor.Right.IsRed = false; } if (parentOfSuccesor != match) { parentOfSuccesor.Left = succesor.Right; succesor.Right = match.Right; } succesor.Left = match.Left; } if (succesor != null) { succesor.IsRed = match.IsRed; } ReplaceChildOrRoot(parentOfMatch, match, succesor); } static void Merge2Nodes(Node parent) { parent.IsRed = false; parent.Left.IsRed = true; parent.Right.IsRed = true; } static void Split4Node(Node node) { node.IsRed = true; node.Left.IsRed = false; node.Right.IsRed = false; } static Node GetSibling(Node node, Node parent) { return parent.Left == node ? parent.Right : parent.Left; } void InsertionBalance(Node current, ref Node parent, Node grandParent, Node greatGrandParent) { bool parentIsOnRight = grandParent.Right == parent; bool currentIsOnRight = parent.Right == current; Node newChildOfGreatGrandParent; if (parentIsOnRight == currentIsOnRight) { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeft(grandParent) : RotateRight(grandParent); } else { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeftRight(grandParent) : RotateRightLeft(grandParent); parent = greatGrandParent; } grandParent.IsRed = true; newChildOfGreatGrandParent.IsRed = false; ReplaceChildOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent); } static Node Rotate(Node node, TreeRotation rotation) { switch (rotation) { case TreeRotation.Right: node.Left.Left.IsRed = false; return RotateRight(node); case TreeRotation.Left: node.Right.Right.IsRed = false; return RotateLeft(node); case TreeRotation.RightLeft: return RotateRightLeft(node); case TreeRotation.LeftRight: return RotateLeftRight(node); default: throw new InvalidOperationException(); } } static Node RotateLeft(Node node) { Node child = node.Right; node.Right = child.Left; child.Left = node; return child; } static Node RotateLeftRight(Node node) { Node child = node.Left; Node grandChild = child.Right; node.Left = grandChild.Right; grandChild.Right = node; child.Right = grandChild.Left; grandChild.Left = child; return grandChild; } static Node RotateRight(Node node) { Node child = node.Left; node.Left = child.Right; child.Right = node; return child; } static Node RotateRightLeft(Node node) { Node child = node.Right; Node grandChild = child.Left; node.Right = grandChild.Left; grandChild.Left = node; child.Left = grandChild.Right; grandChild.Right = child; return grandChild; } void ReplaceChildOrRoot(Node parent, Node child, Node newChild) { if (parent != null) { if (parent.Left == child) { parent.Left = newChild; } else { parent.Right = newChild; } } else { root = newChild; } } static TreeRotation GetRotation(Node parent, Node current, Node sibling) { if (IsNonNullRed(sibling.Left)) { if (parent.Left == current) { return TreeRotation.RightLeft; } return TreeRotation.Right; } else { if (parent.Left == current) { return TreeRotation.Left; } return TreeRotation.LeftRight; } } public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>> { readonly SetDictionary<TKey, TValue> tree; readonly Stack<Node> stack; Node current; readonly bool reverse; internal Enumerator(SetDictionary<TKey, TValue> set) : this(set, false, null) { } internal Enumerator(SetDictionary<TKey, TValue> set, bool reverse, Node startNode) { tree = set; stack = new Stack<Node>(2 * Log2(tree.Count + 1)); current = null; this.reverse = reverse; if (startNode == null) IntializeAll(); else Intialize(startNode); } void IntializeAll() { var node = tree.root; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } } void Intialize(Node startNode) { if (startNode == null) throw new InvalidOperationException(nameof(startNode) + ""is null""); current = null; var node = startNode; var list = new List<Node>(Log2(tree.Count + 1)); var comparer = tree.comparer; if (reverse) { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Key, node.Key) >= 0) list.Add(node); node = node.Parent; } } else { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Key, node.Key) <= 0) list.Add(node); node = node.Parent; } } list.Reverse(); foreach (var n in list) stack.Push(n); } [MethodImpl(MethodImplOptions.AggressiveInlining)] static int Log2(int num) => BitOperations.Log2((uint)num) + 1; public KeyValuePair<TKey, TValue> Current => current == null ? default : current.Pair; public bool MoveNext() { if (stack.Count == 0) { current = null; return false; } current = stack.Pop(); var node = reverse ? current.Left : current.Right; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } return true; } object IEnumerator.Current => Current; public void Dispose() { } public void Reset() => throw new NotSupportedException(); } public class Node { public bool IsRed; public TKey Key; public TValue Value; public KeyValuePair<TKey, TValue> Pair => KeyValuePair.Create(Key, Value); public Node Parent { get; private set; } Node _left; public Node Left { get { return _left; } set { _left = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } Node _right; public Node Right { get { return _right; } set { _right = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } public int Size { get; private set; } = 1; public Node(KeyValuePair<TKey, TValue> pair, bool isRed) { Key = pair.Key; Value = pair.Value; IsRed = isRed; } public Node(TKey key, TValue value, bool isRed) { Key = key; Value = value; IsRed = isRed; } public bool UpdateSize() { var oldsize = Size; var size = 1; if (Left != null) size += Left.Size; if (Right != null) size += Right.Size; Size = size; return oldsize != size; } public override string ToString() => $""Size = {Size}, Item = {Key}""; } enum TreeRotation : byte { Left = 1, Right = 2, RightLeft = 3, LeftRight = 4, } } } "),
new AclFileInfo(@"DataStructure/LazySegtree.cs", new string[] { @"AtCoder.DataStructure.IMonoidFuncOperator<T, F>", @"AtCoder.DataStructure.LazySegtree<TValue, F, TOp>", @"AtCoder.DataStructure.LazySegtree<TValue, F, TOp>.DebugItem", @"AtCoder.DataStructure.LazySegtree<TValue, F, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder.DataStructure { public interface IMonoidFuncOperator<T, F> { T Identity { get; } F FIdentity { get; } T Operate(T x, T y); T Mapping(F f, T x); F Composition(F f, F g); } [DebuggerTypeProxy(typeof(LazySegtree<,,>.DebugView))] public class LazySegtree<TValue, F, TOp> where TOp : struct, IMonoidFuncOperator<TValue, F> { private static readonly TOp op = default; public int Length { get; } public TValue Slice(int from, int length) => Prod(from, from + length); private readonly int log; private readonly int size; private readonly TValue[] d; private readonly F[] lz; public LazySegtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); AssertFIdentity(op.Identity); AssertF(op.FIdentity, op.Identity, op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; lz = new F[size]; Array.Fill(d, op.Identity); Array.Fill(lz, op.FIdentity); } public LazySegtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); [MethodImpl(MethodImplOptions.AggressiveInlining)] private void AllApply(int k, F f) { AssertF(f, op.Identity, op.Identity); AssertMonoid(d[k]); AssertFIdentity(d[k]); AssertF(f, d[k], d[k]); d[k] = op.Mapping(f, d[k]); if (k < size) lz[k] = op.Composition(f, lz[k]); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Push(int k) { AllApply(2 * k, lz[k]); AllApply(2 * k + 1, lz[k]); lz[k] = op.FIdentity; } public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); return d[p]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return op.Identity; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push(r >> i); } TValue sml = op.Identity, smr = op.Identity; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } return op.Operate(sml, smr); } public TValue AllProd => d[1]; public void Apply(int p, F f) { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = op.Mapping(f, d[p]); for (int i = 1; i <= log; i++) Update(p >> i); } public void Apply(int l, int r, F f) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push((r - 1) >> i); } { int l2 = l, r2 = r; while (l < r) { if ((l & 1) != 0) AllApply(l++, f); if ((r & 1) != 0) AllApply(--r, f); l >>= 1; r >>= 1; } l = l2; r = r2; } for (int i = 1; i <= log; i++) { if (((l >> i) << i) != l) Update(l >> i); if (((r >> i) << i) != r) Update((r - 1) >> i); } } public int MaxRight(int l, Predicate<TValue> g) { Debug.Assert((uint)l <= Length); Debug.Assert(g(op.Identity)); if (l == Length) return Length; l += size; for (int i = log; i >= 1; i--) Push(l >> i); TValue sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!g(op.Operate(sm, d[l]))) { while (l < size) { Push(l); l = (2 * l); if (g(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> g) { Debug.Assert((uint)r <= Length); Debug.Assert(g(op.Identity)); if (r == 0) return 0; r += size; for (int i = log; i >= 1; i--) Push((r - 1) >> i); TValue sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!g(op.Operate(d[r], sm))) { while (r < size) { Push(r); r = (2 * r + 1); if (g(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return -1; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Lazy = {"" + nameof(lazy) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value, F lazy) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; this.lazy = lazy; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly F lazy; } private class DebugView { private readonly LazySegtree<TValue, F, TOp> segtree; public DebugView(LazySegtree<TValue, F, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) { int dataIndex = i + len; if ((uint)dataIndex < segtree.lz.Length) items.Add(new DebugItem(l, r, segtree.d[dataIndex], segtree.lz[dataIndex])); else items.Add(new DebugItem(l, r, segtree.d[dataIndex], op.FIdentity)); } } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertFIdentity(TValue value) { Debug.Assert(op.Mapping(op.FIdentity, value).Equals(value), $""{nameof(op.Mapping)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertF(F f, TValue v1, TValue v2) { Debug.Assert(op.Mapping(op.FIdentity, op.Operate(v1, v2)).Equals(op.Operate(op.Mapping(op.FIdentity, v1), op.Mapping(op.FIdentity, v2))), $""{nameof(op.Mapping)}({nameof(op.Operate)}({v1}, {v2})) != {nameof(op.Operate)}({nameof(op.Mapping)}({op.Identity}, {v1}), {nameof(op.Mapping)}({op.Identity}, {v2}))""); } } } "),
new AclFileInfo(@"DataStructure/Segtree.cs", new string[] { @"AtCoder.DataStructure.IMonoidOperator<T>", @"AtCoder.DataStructure.Segtree<TValue, TOp>", @"AtCoder.DataStructure.Segtree<TValue, TOp>.DebugItem", @"AtCoder.DataStructure.Segtree<TValue, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder.DataStructure { public interface IMonoidOperator<T> { T Identity { get; } T Operate(T x, T y); } [DebuggerTypeProxy(typeof(Segtree<,>.DebugView))] public class Segtree<TValue, TOp> where TOp : struct, IMonoidOperator<TValue> { private static readonly TOp op = default; public int Length { get; } public TValue Slice(int from, int length) => Prod(from, from + length); private readonly int log; private readonly int size; private readonly TValue[] d; public Segtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; Array.Fill(d, op.Identity); } public Segtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { AssertMonoid(value); Debug.Assert((uint)p < Length); p += size; d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); AssertMonoid(d[p + size]); return d[p + size]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); TValue sml = op.Identity, smr = op.Identity; l += size; r += size; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } AssertMonoid(op.Operate(sml, smr)); return op.Operate(sml, smr); } public TValue AllProd => d[1]; public int MaxRight(int l, Predicate<TValue> f) { Debug.Assert((uint)l <= Length); Debug.Assert(f(op.Identity)); if (l == Length) return Length; l += size; var sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!f(op.Operate(sm, d[l]))) { while (l < size) { l = (2 * l); if (f(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> f) { Debug.Assert((uint)r <= Length); Debug.Assert(f(op.Identity)); if (r == 0) return 0; r += size; var sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!f(op.Operate(d[r], sm))) { while (r < size) { r = (2 * r + 1); if (f(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return -1; } [DebuggerDisplay(""{"" + nameof(value) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; } private class DebugView { private readonly Segtree<TValue, TOp> segtree; public DebugView(Segtree<TValue, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) items.Add(new DebugItem(l, r, segtree.d[i + len])); } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } } } "),
new AclFileInfo(@"DataStructure/Sums.cs", new string[] { @"AtCoder.DataStructure.Sums" }, new string[] {  }, new string[] {  }, @"namespace AtCoder.DataStructure { public class Sums { readonly long[] impl; public int Length => impl.Length - 1; public Sums(int[] arr) { impl = new long[arr.Length + 1]; for (var i = 0; i < arr.Length; i++) impl[i + 1] = impl[i] + arr[i]; } public long Slice(int from, int length) => impl[from + length] - impl[from]; public long this[int toExclusive] => impl[toExclusive]; public long this[int from, int toExclusive] => impl[toExclusive] - impl[from]; } } "),
new AclFileInfo(@"DataStructure/Sums2D.cs", new string[] { @"AtCoder.DataStructure.Sums2D", @"AtCoder.DataStructure.Sums2D.Slicer" }, new string[] {  }, new string[] {  }, @"namespace AtCoder.DataStructure { public class Sums2D { readonly long[][] impl; public int Length => impl.Length - 1; public Sums2D(int[][] arr) { impl = new long[arr.Length + 1][]; impl[0] = new long[arr[0].Length + 1]; for (var i = 0; i < arr.Length; i++) { impl[i + 1] = new long[arr[i].Length + 1]; for (var j = 0; j < arr[i].Length; j++) impl[i + 1][j + 1] = impl[i + 1][j] + impl[i][j + 1] - impl[i][j] + arr[i][j]; } } public Slicer Slice(int left, int length) => new Slicer(impl, left, left + length); public ref struct Slicer { readonly long[][] impl; readonly int left; readonly int rightExclusive; public int Length { get; } public Slicer(long[][] impl, int left, int rightExclusive) { this.impl = impl; this.left = left; this.rightExclusive = rightExclusive; this.Length = impl[0].Length - 1; } public long Slice(int top, int length) { var bottomExclusive = top + length; return impl[rightExclusive][bottomExclusive] - impl[left][bottomExclusive] - impl[rightExclusive][top] + impl[left][top]; } } } } "),
new AclFileInfo(@"DataStructure/FenwickTree.cs", new string[] { @"AtCoder.DataStructure.IntFenwickTree", @"AtCoder.DataStructure.UIntFenwickTree", @"AtCoder.DataStructure.LongFenwickTree", @"AtCoder.DataStructure.ULongFenwickTree", @"AtCoder.DataStructure.ModIntFenwickTree<T>", @"AtCoder.DataStructure.FenwickTree<TValue, TOp>", @"AtCoder.DataStructure.FenwickTree<TValue, TOp>.DebugItem", @"AtCoder.DataStructure.FenwickTree<TValue, TOp>.DebugView" }, new string[] { @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Algebra;", @"using AtCoder.Internal;" }, new string[] { @"Algebra/Operators.cs", @"Math/StaticModInt.cs", @"Math/ModSeed.cs", @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder.DataStructure { public class IntFenwickTree : FenwickTree<int, IntOperator> { public IntFenwickTree(int n) : base(n) { } } public class UIntFenwickTree : FenwickTree<uint, UIntOperator> { public UIntFenwickTree(int n) : base(n) { } } public class LongFenwickTree : FenwickTree<long, LongOperator> { public LongFenwickTree(int n) : base(n) { } } public class ULongFenwickTree : FenwickTree<ulong, ULongOperator> { public ULongFenwickTree(int n) : base(n) { } } public class ModIntFenwickTree<T> : FenwickTree<StaticModInt<T>, StaticModIntOperator<T>> where T : struct, IStaticMod { public ModIntFenwickTree(int n) : base(n) { } } [DebuggerTypeProxy(typeof(FenwickTree<,>.DebugView))] public class FenwickTree<TValue, TOp> where TOp : IAddOperator<TValue>, ISubtractOperator<TValue> { private static readonly TOp op = default; internal readonly TValue[] data; public int Length { get; } public TValue Slice(int from, int length) => Sum(from, from + length); public FenwickTree(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); Length = n; data = new TValue[n + 1]; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Add(int p, TValue x) { Debug.Assert(unchecked((uint)p < data.Length)); for (p++; p < data.Length; p += InternalBit.ExtractLowestSetBit(p)) { data[p] = op.Add(data[p], x); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Sum(int l, int r) { Debug.Assert(0 <= l && l <= r && r < data.Length); return op.Subtract(Sum(r), Sum(l)); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Sum(int r) { TValue s = default; for (; r > 0; r -= InternalBit.ExtractLowestSetBit(r)) { s = op.Add(s, data[r]); } return s; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Sum = {"" + nameof(sum) + ""}"")] internal struct DebugItem { public DebugItem(TValue value, TValue sum) { this.sum = sum; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue sum; } internal class DebugView { private readonly FenwickTree<TValue, TOp> fenwickTree; public DebugView(FenwickTree<TValue, TOp> fenwickTree) { this.fenwickTree = fenwickTree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var data = fenwickTree.data; var items = new DebugItem[data.Length - 1]; items[0] = new DebugItem(data[1], data[1]); for (int i = 2; i < data.Length; i++) { int length = InternalBit.ExtractLowestSetBit(i); var pr = i - length - 1; var sum = op.Add(data[i], 0 <= pr ? items[pr].sum : default); var val = op.Subtract(sum, items[i - 2].sum); items[i - 1] = new DebugItem(val, sum); } return items; } } } } } "),
new AclFileInfo(@"DataStructure/FenwickTreeExtension.cs", new string[] { @"AtCoder.DataStructure.FenwickTreeExtension" }, new string[] { @"using AtCoder.Algebra;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"DataStructure/FenwickTree.cs", @"Algebra/Operators.cs" }, @"namespace AtCoder.DataStructure { public static class FenwickTreeExtension { public static int LowerBound<TValue, TOp>(this FenwickTree<TValue, TOp> fw, TValue w) where TOp : IAddOperator<TValue>, ISubtractOperator<TValue>, IComparisonOperator<TValue> { var op = default(TOp); if (op.LessThanOrEqual(w, default)) return 0; int x = 0; for (int k = 1 << MSB(fw.data.Length - 1); k > 0; k >>= 1) { var nx = x + k; if (nx < fw.data.Length && op.LessThan(fw.data[nx], w)) { x = nx; w = op.Subtract(w, fw.data[nx]); } } return x; } } } "),
new AclFileInfo(@"Algebra/Operators.cs", new string[] { @"AtCoder.Algebra.IAddOperator<T>", @"AtCoder.Algebra.ISubtractOperator<T>", @"AtCoder.Algebra.IMultiplyOperator<T>", @"AtCoder.Algebra.IDivideOperator<T>", @"AtCoder.Algebra.IModuloOperator<T>", @"AtCoder.Algebra.INegateOperator<T>", @"AtCoder.Algebra.IIncrementOperator<T>", @"AtCoder.Algebra.IDecrementOperator<T>", @"AtCoder.Algebra.IComparisonOperator<T>", @"AtCoder.Algebra.IRangedType<T>", @"AtCoder.Algebra.INumOperator<T>", @"AtCoder.Algebra.ISignedNumOperator<T>", @"AtCoder.Algebra.IntOperator", @"AtCoder.Algebra.LongOperator", @"AtCoder.Algebra.UIntOperator", @"AtCoder.Algebra.ULongOperator", @"AtCoder.Algebra.DoubleOperator" }, new string[] { @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.Algebra { public interface IAddOperator<T> { T Add(T x, T y); } public interface ISubtractOperator<T> { T Subtract(T x, T y); } public interface IMultiplyOperator<T> { T Multiply(T x, T y); } public interface IDivideOperator<T> { T Divide(T x, T y); } public interface IModuloOperator<T> { T Modulo(T x, T y); } public interface INegateOperator<T> { T Negate(T x); } public interface IIncrementOperator<T> : IAddOperator<T> { T Increment(T x); } public interface IDecrementOperator<T> : ISubtractOperator<T> { T Decrement(T x); } public interface IComparisonOperator<T> : IComparer<T> { bool GreaterThan(T x, T y); bool GreaterThanOrEqual(T x, T y); bool LessThan(T x, T y); bool LessThanOrEqual(T x, T y); } public interface IRangedType<T> { public T MinValue { get; } public T MaxValue { get; } } public interface INumOperator<T> : IAddOperator<T>, ISubtractOperator<T>, IMultiplyOperator<T>, IDivideOperator<T>, IModuloOperator<T>, IIncrementOperator<T>, IDecrementOperator<T>, IComparisonOperator<T>, IRangedType<T>, IEqualityComparer<T> { } public interface ISignedNumOperator<T> : INumOperator<T>, INegateOperator<T> { } public readonly struct IntOperator : ISignedNumOperator<int> { public int MinValue => int.MinValue; public int MaxValue => int.MaxValue; public int Add(int x, int y) => x + y; public int Subtract(int x, int y) => x - y; public int Multiply(int x, int y) => x * y; public int Divide(int x, int y) => x / y; public int Modulo(int x, int y) => x % y; public int Negate(int x) => -x; public int Increment(int x) => ++x; public int Decrement(int x) => --x; public bool GreaterThan(int x, int y) => x > y; public bool GreaterThanOrEqual(int x, int y) => x >= y; public bool LessThan(int x, int y) => x < y; public bool LessThanOrEqual(int x, int y) => x <= y; public int Compare(int x, int y) => x.CompareTo(y); public bool Equals(int x, int y) => x == y; public int GetHashCode(int obj) => obj.GetHashCode(); } public readonly struct LongOperator : ISignedNumOperator<long> { public long MinValue => long.MinValue; public long MaxValue => long.MaxValue; public long Add(long x, long y) => x + y; public long Subtract(long x, long y) => x - y; public long Multiply(long x, long y) => x * y; public long Divide(long x, long y) => x / y; public long Modulo(long x, long y) => x % y; public long Negate(long x) => -x; public long Increment(long x) => ++x; public long Decrement(long x) => --x; public bool GreaterThan(long x, long y) => x > y; public bool GreaterThanOrEqual(long x, long y) => x >= y; public bool LessThan(long x, long y) => x < y; public bool LessThanOrEqual(long x, long y) => x <= y; public int Compare(long x, long y) => x.CompareTo(y); public bool Equals(long x, long y) => x == y; public int GetHashCode(long obj) => obj.GetHashCode(); } public readonly struct UIntOperator : INumOperator<uint> { public uint MinValue => uint.MinValue; public uint MaxValue => uint.MaxValue; public uint Add(uint x, uint y) => x + y; public uint Subtract(uint x, uint y) => x - y; public uint Multiply(uint x, uint y) => x * y; public uint Divide(uint x, uint y) => x / y; public uint Modulo(uint x, uint y) => x % y; public uint Increment(uint x) => ++x; public uint Decrement(uint x) => --x; public bool GreaterThan(uint x, uint y) => x > y; public bool GreaterThanOrEqual(uint x, uint y) => x >= y; public bool LessThan(uint x, uint y) => x < y; public bool LessThanOrEqual(uint x, uint y) => x <= y; public int Compare(uint x, uint y) => x.CompareTo(y); public bool Equals(uint x, uint y) => x == y; public int GetHashCode(uint obj) => obj.GetHashCode(); } public readonly struct ULongOperator : INumOperator<ulong> { public ulong MinValue => ulong.MinValue; public ulong MaxValue => ulong.MaxValue; public ulong Add(ulong x, ulong y) => x + y; public ulong Subtract(ulong x, ulong y) => x - y; public ulong Multiply(ulong x, ulong y) => x * y; public ulong Divide(ulong x, ulong y) => x / y; public ulong Modulo(ulong x, ulong y) => x % y; public ulong Increment(ulong x) => ++x; public ulong Decrement(ulong x) => --x; public bool GreaterThan(ulong x, ulong y) => x > y; public bool GreaterThanOrEqual(ulong x, ulong y) => x >= y; public bool LessThan(ulong x, ulong y) => x < y; public bool LessThanOrEqual(ulong x, ulong y) => x <= y; public int Compare(ulong x, ulong y) => x.CompareTo(y); public bool Equals(ulong x, ulong y) => x == y; public int GetHashCode(ulong obj) => obj.GetHashCode(); } public readonly struct DoubleOperator : ISignedNumOperator<double> { public double MinValue => double.MinValue; public double MaxValue => double.MaxValue; public double Add(double x, double y) => x + y; public double Subtract(double x, double y) => x - y; public double Multiply(double x, double y) => x * y; public double Divide(double x, double y) => x / y; public double Modulo(double x, double y) => x % y; public double Negate(double x) => -x; public double Increment(double x) => ++x; public double Decrement(double x) => --x; public bool GreaterThan(double x, double y) => x > y; public bool GreaterThanOrEqual(double x, double y) => x >= y; public bool LessThan(double x, double y) => x < y; public bool LessThanOrEqual(double x, double y) => x <= y; public int Compare(double x, double y) => x.CompareTo(y); public bool Equals(double x, double y) => x == y; public int GetHashCode(double obj) => obj.GetHashCode(); } } "),
new AclFileInfo(@"Math/ModSeed.cs", new string[] { @"AtCoder.IStaticMod", @"AtCoder.Mod1000000007", @"AtCoder.Mod998244353", @"AtCoder.IDynamicModID", @"AtCoder.ModID0", @"AtCoder.ModID1", @"AtCoder.ModID2", @"AtCoder.StaticModIntOperator<T>" }, new string[] { @"using AtCoder.Algebra;", @"using System.Collections.Generic;" }, new string[] { @"Algebra/Operators.cs", @"Math/StaticModInt.cs" }, @"namespace AtCoder { public interface IStaticMod { uint Mod { get; } bool IsPrime { get; } } public readonly struct Mod1000000007 : IStaticMod { public uint Mod => 1000000007; public bool IsPrime => true; } public readonly struct Mod998244353 : IStaticMod { public uint Mod => 998244353; public bool IsPrime => true; } public interface IDynamicModID { } public readonly struct ModID0 : IDynamicModID { } public readonly struct ModID1 : IDynamicModID { } public readonly struct ModID2 : IDynamicModID { } public readonly struct StaticModIntOperator<T> : IAddOperator<StaticModInt<T>>, ISubtractOperator<StaticModInt<T>>, IMultiplyOperator<StaticModInt<T>>, IDivideOperator<StaticModInt<T>>, IIncrementOperator<StaticModInt<T>>, IDecrementOperator<StaticModInt<T>>, INegateOperator<StaticModInt<T>>, IEqualityComparer<StaticModInt<T>> where T : struct, IStaticMod { public StaticModInt<T> Add(StaticModInt<T> x, StaticModInt<T> y) => x + y; public StaticModInt<T> Subtract(StaticModInt<T> x, StaticModInt<T> y) => x - y; public StaticModInt<T> Multiply(StaticModInt<T> x, StaticModInt<T> y) => x * y; public StaticModInt<T> Divide(StaticModInt<T> x, StaticModInt<T> y) => x / y; public StaticModInt<T> Negate(StaticModInt<T> x) => -x; public StaticModInt<T> Increment(StaticModInt<T> x) => ++x; public StaticModInt<T> Decrement(StaticModInt<T> x) => --x; public bool Equals(StaticModInt<T> x, StaticModInt<T> y) => x == y; public int GetHashCode(StaticModInt<T> obj) => obj.GetHashCode(); } } "),
new AclFileInfo(@"Math/StaticModInt.cs", new string[] { @"AtCoder.StaticModInt<T>" }, new string[] { @"using AtCoder.Algebra;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Math/ModSeed.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder { public readonly struct StaticModInt<T> where T : struct, IStaticMod { private readonly uint _v; public int Value => (int)_v; public static int Mod => (int)default(T).Mod; public static StaticModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(u < Mod); return new StaticModInt<T>(u); } public StaticModInt(long v) : this(Round(v)) { } private StaticModInt(uint v) => _v = v; private static uint Round(long v) { var x = v % default(T).Mod; if (x < 0) { x += default(T).Mod; } return (uint)x; } public static StaticModInt<T> operator ++(StaticModInt<T> value) { var v = value._v + 1; if (v == default(T).Mod) { v = 0; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator --(StaticModInt<T> value) { var v = value._v; if (v == 0) { v = default(T).Mod; } return new StaticModInt<T>(v - 1); } public static StaticModInt<T> operator +(StaticModInt<T> lhs, StaticModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= default(T).Mod) { v -= default(T).Mod; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator -(StaticModInt<T> lhs, StaticModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= default(T).Mod) { v += default(T).Mod; } return new StaticModInt<T>(v); } } public static StaticModInt<T> operator *(StaticModInt<T> lhs, StaticModInt<T> rhs) { return new StaticModInt<T>((uint)((ulong)lhs._v * rhs._v % default(T).Mod)); } public static StaticModInt<T> operator /(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs * rhs.Inv(); public static StaticModInt<T> operator +(StaticModInt<T> value) => value; public static StaticModInt<T> operator -(StaticModInt<T> value) => new StaticModInt<T>() - value; public static bool operator ==(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator StaticModInt<T>(int value) => new StaticModInt<T>(value); public static implicit operator StaticModInt<T>(long value) => new StaticModInt<T>(value); public StaticModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new StaticModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public StaticModInt<T> Inv() { if (default(T).IsPrime) { Debug.Assert(_v > 0); return Pow(default(T).Mod - 2); } else { var (g, x) = Internal.InternalMath.InvGCD(_v, default(T).Mod); Debug.Assert(g == 1); return new StaticModInt<T>(x); } } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is StaticModInt<T> m && this == m; public override int GetHashCode() => _v.GetHashCode(); } }"),
new AclFileInfo(@"Math/PrimeNumber.cs", new string[] { @"AtCoder.PrimeNumber" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] { @"Extensions.cs" }, @"namespace AtCoder { public class PrimeNumber : ICollection<int> { readonly int[] primes; readonly int[] searches; public int Count => primes.Length; public bool IsReadOnly => true; public PrimeNumber(int max) { (primes, searches) = Eratosthenes(max); } public Dictionary<long, int> PrimeFactoring(long num) { var primeFactors = new Dictionary<long, int>(); foreach (var p in EnumerateFactor(num)) { primeFactors[p] = primeFactors.Get(p) + 1; } return primeFactors; } public Dictionary<int, int> PrimeFactoring(int num) { if (num < searches.Length) return PrimeFactoringFast(num); var primeFactors = new Dictionary<int, int>(); foreach (var pl in EnumerateFactor(num)) { var p = (int)pl; primeFactors[p] = primeFactors.Get(p) + 1; } return primeFactors; } IEnumerable<long> EnumerateFactor(long num) { if ((long)primes[^1] * primes[^1] < num) throw new ArgumentOutOfRangeException(nameof(num)); foreach (var p in primes) { if (num < 2) break; while (DivIfMulti(ref num, p)) yield return p; } if (num > 1) yield return num; static bool DivIfMulti(ref long num, long p) { Math.DivRem(num, p, out var d); if (d == 0) { num /= p; return true; } return false; } } Dictionary<int, int> PrimeFactoringFast(int num) { if (num >= searches.Length) throw new ArgumentOutOfRangeException(nameof(num)); var primeFactors = new Dictionary<int, int>(); while (num > 1) { primeFactors[searches[num]] = primeFactors.Get(searches[num]) + 1; num /= searches[num]; } return primeFactors; } static (int[] primes, int[] searches) Eratosthenes(int n) { var searches = new int[n + 1]; Array.Copy(new int[11] { 0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2 }, searches, Math.Min(11, searches.Length)); var primes = new List<int>(n) { 2, 3, 5, 7 }; if (n < 11) return (primes.TakeWhile(p => p <= n).ToArray(), searches); for (int i = 11; i < searches.Length; i += 2) { searches[i - 1] = 2; if (i % 3 == 0) searches[i] = 3; else if (i % 5 == 0) searches[i] = 5; else if (i % 7 == 0) searches[i] = 7; } if (n % 2 == 0) searches[n] = 2; var current = 11; while (current * current <= n) { primes.Add(current); var c2 = current << 1; for (var i = current; i < searches.Length; i += c2) if (searches[i] == 0) searches[i] = current; while (searches[current] > 0) current += 2; } for (var i = current; i < searches.Length; i += 2) if (searches[i] == 0) { searches[i] = i; primes.Add(i); } return (primes.ToArray(), searches); } public void Add(int item) => throw new NotSupportedException(); public void Clear() => throw new NotSupportedException(); public bool Contains(int item) => primes.Contains(item); public void CopyTo(int[] array, int arrayIndex) => primes.CopyTo(array, arrayIndex); public bool Remove(int item) => throw new NotSupportedException(); public ReadOnlySpan<int>.Enumerator GetEnumerator() => new ReadOnlySpan<int>(primes).GetEnumerator(); IEnumerator<int> IEnumerable<int>.GetEnumerator() => ((IEnumerable<int>)primes).GetEnumerator(); IEnumerator IEnumerable.GetEnumerator() => primes.GetEnumerator(); } } "),
new AclFileInfo(@"Math/MathLib.cs", new string[] { @"AtCoder.MathLib", @"AtCoder.MathLib.FFTMod1", @"AtCoder.MathLib.FFTMod2", @"AtCoder.MathLib.FFTMod3" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using AtCoder.Internal;" }, new string[] { @"Math/Internal/Barrett.cs", @"Math/Internal/InternalMath.cs", @"Math/ModSeed.cs", @"Math/StaticModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/Butterfly.cs" }, @"namespace AtCoder { public static class MathLib { public static IEnumerable<int> Divisor(int n) { var list = new List<int>(); for (int i = 1, d = Math.DivRem(n, i, out int amari); i <= d; i++, d = Math.DivRem(n, i, out amari)) { if (amari == 0) { yield return i; if (i != d) list.Add(d); } } for (var i = list.Count - 1; i >= 0; i--) yield return list[i]; } public static IEnumerable<long> Divisor(long n) { var list = new List<long>(); for (long i = 1, d = Math.DivRem(n, i, out long amari); i <= d; i++, d = Math.DivRem(n, i, out amari)) { if (amari == 0) { yield return i; if (i != d) list.Add(d); } } for (var i = list.Count - 1; i >= 0; i--) yield return list[i]; } public static long PowMod(long x, long n, int m) { Debug.Assert(0 <= n && 1 <= m); if (m == 1) return 0; Barrett barrett = new Barrett((uint)m); uint r = 1, y = (uint)InternalMath.SafeMod(x, m); while (0 < n) { if ((n & 1) != 0) r = barrett.Mul(r, y); y = barrett.Mul(y, y); n >>= 1; } return r; } public static long InvMod(long x, int m) { Debug.Assert(1 <= m); var (g, res) = InternalMath.InvGCD(x, m); Debug.Assert(g == 1); return res; } public static (long, long) CRT(long[] r, long[] m) { Debug.Assert(r.Length == m.Length); long r0 = 0, m0 = 1; for (int i = 0; i < m.Length; i++) { Debug.Assert(1 <= m[i]); long r1 = InternalMath.SafeMod(r[i], m[i]); long m1 = m[i]; if (m0 < m1) { (r0, r1) = (r1, r0); (m0, m1) = (m1, m0); } if (m0 % m1 == 0) { if (r0 % m1 != r1) return (0, 0); continue; } var (g, im) = InternalMath.InvGCD(m0, m1); long u1 = (m1 / g); if ((r1 - r0) % g != 0) return (0, 0); long x = (r1 - r0) / g % u1 * im % u1; r0 += x * m0; m0 *= u1; if (r0 < 0) r0 += m0; } return (r0, m0); } public static long FloorSum(long n, long m, long a, long b) { long ans = 0; while (true) { if (a >= m) { ans += (n - 1) * n * (a / m) / 2; a %= m; } if (b >= m) { ans += n * (b / m); b %= m; } long yMax = (a * n + b) / m; long xMax = yMax * m - b; if (yMax == 0) return ans; ans += (n - (xMax + a - 1) / a) * yMax; (n, m, a, b) = (yMax, a, m, (a - xMax % a) % a); } } public static int[] Convolution(int[] a, int[] b) => Convolution<Mod998244353>(a, b); public static uint[] Convolution(uint[] a, uint[] b) => Convolution<Mod998244353>(a, b); public static long[] Convolution(long[] a, long[] b) => Convolution<Mod998244353>(a, b); public static ulong[] Convolution(ulong[] a, ulong[] b) => Convolution<Mod998244353>(a, b); public static int[] Convolution<TMod>(int[] a, int[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<int>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new int[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static uint[] Convolution<TMod>(uint[] a, uint[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<uint>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (uint)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new uint[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (uint)c[i].Value; } return result; } } public static long[] Convolution<TMod>(long[] a, long[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (long)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new long[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static ulong[] Convolution<TMod>(ulong[] a, ulong[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<ulong>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(TakeMod).ToArray(), b.Select(TakeMod).ToArray()); return c.Select(ci => (ulong)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = TakeMod(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = TakeMod(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } static StaticModInt<TMod> TakeMod(ulong x) => StaticModInt<TMod>.Raw((int)(x % default(TMod).Mod)); } public static StaticModInt<TMod>[] Convolution<TMod>(StaticModInt<TMod>[] a, StaticModInt<TMod>[] b) where TMod : struct, IStaticMod { var temp = Convolution((ReadOnlySpan<StaticModInt<TMod>>)a, b); return temp.ToArray(); } public static Span<StaticModInt<TMod>> Convolution<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<StaticModInt<TMod>>(); } if (Math.Min(n, m) <= 60) { return ConvolutionNaive(a, b); } int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; a.CopyTo(aTemp); var bTemp = new StaticModInt<TMod>[z]; b.CopyTo(bTemp); return Convolution(aTemp.AsSpan(), bTemp.AsSpan(), n, m, z); } private static Span<StaticModInt<TMod>> Convolution<TMod>(Span<StaticModInt<TMod>> a, Span<StaticModInt<TMod>> b, int n, int m, int z) where TMod : struct, IStaticMod { Internal.Butterfly<TMod>.Calculate(a); Internal.Butterfly<TMod>.Calculate(b); for (int i = 0; i < a.Length; i++) { a[i] *= b[i]; } Internal.Butterfly<TMod>.CalculateInv(a); var result = a[0..(n + m - 1)]; var iz = new StaticModInt<TMod>(z).Inv(); foreach (ref var r in result) { r *= iz; } return result; } public static long[] ConvolutionLong(ReadOnlySpan<long> a, ReadOnlySpan<long> b) { unchecked { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } const ulong Mod1 = 754974721; const ulong Mod2 = 167772161; const ulong Mod3 = 469762049; const ulong M2M3 = Mod2 * Mod3; const ulong M1M3 = Mod1 * Mod3; const ulong M1M2 = Mod1 * Mod2; const ulong M1M2M3 = Mod1 * Mod2 * Mod3; ulong i1 = (ulong)Internal.InternalMath.InvGCD((long)M2M3, (long)Mod1).Item2; ulong i2 = (ulong)Internal.InternalMath.InvGCD((long)M1M3, (long)Mod2).Item2; ulong i3 = (ulong)Internal.InternalMath.InvGCD((long)M1M2, (long)Mod3).Item2; var c1 = Convolution<FFTMod1>(a, b); var c2 = Convolution<FFTMod2>(a, b); var c3 = Convolution<FFTMod3>(a, b); var c = new long[n + m - 1]; Span<ulong> offset = stackalloc ulong[] { 0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 }; for (int i = 0; i < c.Length; i++) { ulong x = 0; x += (c1[i] * i1) % Mod1 * M2M3; x += (c2[i] * i2) % Mod2 * M1M3; x += (c3[i] * i3) % Mod3 * M1M2; long diff = (long)c1[i] - Internal.InternalMath.SafeMod((long)x, (long)Mod1); if (diff < 0) { diff += (long)Mod1; } x -= offset[(int)(diff % offset.Length)]; c[i] = (long)x; } return c; } static ulong[] Convolution<TMod>(ReadOnlySpan<long> a, ReadOnlySpan<long> b) where TMod : struct, IStaticMod { int z = 1 << Internal.InternalBit.CeilPow2(a.Length + b.Length - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = AtCoder.MathLib.Convolution<TMod>(aTemp, bTemp, a.Length, b.Length, z); var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } } private static StaticModInt<TMod>[] ConvolutionNaive<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { if (a.Length < b.Length) { var temp = a; a = b; b = temp; } var ans = new StaticModInt<TMod>[a.Length + b.Length - 1]; for (int i = 0; i < a.Length; i++) { for (int j = 0; j < b.Length; j++) { ans[i + j] += a[i] * b[j]; } } return ans; } private readonly struct FFTMod1 : IStaticMod { public uint Mod => 754974721; public bool IsPrime => true; } private readonly struct FFTMod2 : IStaticMod { public uint Mod => 167772161; public bool IsPrime => true; } private readonly struct FFTMod3 : IStaticMod { public uint Mod => 469762049; public bool IsPrime => true; } } } "),
new AclFileInfo(@"Math/Fraction.cs", new string[] { @"AtCoder.Fraction" }, new string[] { @"using System;" }, new string[] { @"Global.cs" }, @"namespace AtCoder { public readonly struct Fraction : IEquatable<Fraction>, IComparable<Fraction> { public readonly long numerator; public readonly long denominator; public Fraction(long , long ) { var sign = Math.Sign() * Math.Sign();  = Math.Abs();  = Math.Abs(); var gcd = Global.Gcd(, ); numerator = sign *  / gcd; denominator =  / gcd; } public override string ToString() => $""{numerator}/{denominator}""; public override bool Equals(object obj) => obj is Fraction f && Equals(f); public bool Equals(Fraction other) => this.numerator == other.numerator && this.denominator == other.denominator; public override int GetHashCode() => HashCode.Combine(numerator, denominator); public static implicit operator Fraction(long x) => new Fraction(x, 1); public int CompareTo(Fraction other) => (this.numerator * other.denominator).CompareTo(other.numerator * this.denominator); public static Fraction operator -(Fraction x) => new Fraction(-x.numerator, x.denominator); public static Fraction operator +(Fraction x, Fraction y) { var gcd = Global.Gcd(x.denominator, y.denominator); var lcm = x.denominator / gcd * y.denominator; return new Fraction((x.numerator * y.denominator + y.numerator * x.denominator) / gcd, lcm); } public static Fraction operator -(Fraction x, Fraction y) { var gcd = Global.Gcd(x.denominator, y.denominator); var lcm = x.denominator / gcd * y.denominator; return new Fraction((x.numerator * y.denominator - y.numerator * x.denominator) / gcd, lcm); } public static Fraction operator *(Fraction x, Fraction y) => new Fraction(x.numerator * y.numerator, x.denominator * y.denominator); public static Fraction operator /(Fraction x, Fraction y) => new Fraction(x.numerator * y.denominator, x.denominator * y.numerator); public static bool operator ==(Fraction x, Fraction y) => x.Equals(y); public static bool operator !=(Fraction x, Fraction y) => !x.Equals(y); public static bool operator >=(Fraction x, Fraction y) => x.CompareTo(y) >= 0; public static bool operator <=(Fraction x, Fraction y) => x.CompareTo(y) <= 0; public static bool operator >(Fraction x, Fraction y) => x.CompareTo(y) > 0; public static bool operator <(Fraction x, Fraction y) => x.CompareTo(y) < 0; public Fraction Inverse() => new Fraction(denominator, numerator); public double ToDouble() => (double)numerator / denominator; } } "),
new AclFileInfo(@"Math/DynamicModInt.cs", new string[] { @"AtCoder.DynamicModInt<T>" }, new string[] { @"using AtCoder.Algebra;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Math/ModSeed.cs", @"Math/Internal/Barrett.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder { public readonly struct DynamicModInt<T> where T : struct, IDynamicModID { private readonly uint _v; private static Internal.Barrett bt; public int Value => (int)_v; public static int Mod { get => (int)bt.Mod; set { Debug.Assert(1 <= value); bt = new Internal.Barrett((uint)value); } } public static DynamicModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(bt != null, $"" {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)}  mod ""); Debug.Assert(u < Mod); return new DynamicModInt<T>(u); } public DynamicModInt(long v) : this(Round(v)) { } private DynamicModInt(uint v) => _v = v; private static uint Round(long v) { Debug.Assert(bt != null, $"" {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)}  mod ""); var x = v % bt.Mod; if (x < 0) { x += bt.Mod; } return (uint)x; } public static DynamicModInt<T> operator ++(DynamicModInt<T> value) { var v = value._v + 1; if (v == bt.Mod) { v = 0; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator --(DynamicModInt<T> value) { var v = value._v; if (v == 0) { v = bt.Mod; } return new DynamicModInt<T>(v - 1); } public static DynamicModInt<T> operator +(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= bt.Mod) { v -= bt.Mod; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator -(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= bt.Mod) { v += bt.Mod; } return new DynamicModInt<T>(v); } } public static DynamicModInt<T> operator *(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { uint z = bt.Mul(lhs._v, rhs._v); return new DynamicModInt<T>(z); } public static DynamicModInt<T> operator /(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs * rhs.Inv(); public static DynamicModInt<T> operator +(DynamicModInt<T> value) => value; public static DynamicModInt<T> operator -(DynamicModInt<T> value) => new DynamicModInt<T>() - value; public static bool operator ==(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator DynamicModInt<T>(int value) => new DynamicModInt<T>(value); public static implicit operator DynamicModInt<T>(long value) => new DynamicModInt<T>(value); public DynamicModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new DynamicModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public DynamicModInt<T> Inv() { var (g, x) = Internal.InternalMath.InvGCD(_v, bt.Mod); Debug.Assert(g == 1); return new DynamicModInt<T>(x); } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is DynamicModInt<T> m && this == m; public override int GetHashCode() => _v.GetHashCode(); } } "),
new AclFileInfo(@"Util/PointInt.cs", new string[] { @"AtCoder.Util.PointInt" }, new string[] { @"using System;" }, new string[] {  }, @"namespace AtCoder.Util { public readonly struct PointInt : IEquatable<PointInt>, IComparable<PointInt> { public readonly int x; public readonly int y; public PointInt(int x, int y) { this.x = x; this.y = y; } [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public void Deconstruct(out int v1, out int v2) { v1 = x; v2 = y; } public static implicit operator PointInt((int x, int y) tuple) => new PointInt(tuple.x, tuple.y); public double Distance(PointInt other) => Math.Sqrt(Distance2(other)); long Distance2(PointInt other) { var p = other - this; return (long)p.x * p.x + (long)p.y * p.y; } public long Inner(PointInt other) => (long)x * other.x + (long)y * other.y; public long Cross(PointInt other) => (long)x * other.y - (long)y * other.x; public static PointInt operator +(PointInt a, PointInt b) => new PointInt(a.x + b.x, a.y + b.y); public static PointInt operator -(PointInt a, PointInt b) => new PointInt(a.x - b.x, a.y - b.y); public int CompareTo(PointInt other) { var xd = this.x.CompareTo(other.x); if (xd != 0) return xd; return this.y.CompareTo(other.y); } public bool Equals(PointInt other) => this.x == other.x && this.y == other.y; public override bool Equals(object obj) => obj is PointInt p && this.Equals(p); public override int GetHashCode() => HashCode.Combine(x, y); public override string ToString() => $""({x}, {y})""; public static bool operator ==(PointInt left, PointInt right) => left.Equals(right); public static bool operator !=(PointInt left, PointInt right) => !left.Equals(right); } } "),
new AclFileInfo(@"Util/PointLong.cs", new string[] { @"AtCoder.Util.PointLong" }, new string[] { @"using System;" }, new string[] {  }, @"namespace AtCoder.Util { public readonly struct PointLong : IEquatable<PointLong>, IComparable<PointLong> { public readonly long x; public readonly long y; public PointLong(long x, long y) { this.x = x; this.y = y; } [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public void Deconstruct(out long v1, out long v2) { v1 = x; v2 = y; } public static implicit operator PointLong((long x, long y) tuple) => new PointLong(tuple.x, tuple.y); public double Distance(PointLong other) => Math.Sqrt(Distance2(other)); long Distance2(PointLong other) { var p = other - this; return p.x * p.x + p.y * p.y; } public long Inner(PointLong other) => x * other.x + y * other.y; public long Cross(PointLong other) => x * other.y - y * other.x; public static PointLong operator +(PointLong a, PointLong b) => new PointLong(a.x + b.x, a.y + b.y); public static PointLong operator -(PointLong a, PointLong b) => new PointLong(a.x - b.x, a.y - b.y); public int CompareTo(PointLong other) { var xd = this.x.CompareTo(other.x); if (xd != 0) return xd; return this.y.CompareTo(other.y); } public bool Equals(PointLong other) => this.x == other.x && this.y == other.y; public override bool Equals(object obj) => obj is PointLong p && this.Equals(p); public override int GetHashCode() => HashCode.Combine(x, y); public override string ToString() => $""({x}, {y})""; public static bool operator ==(PointLong left, PointLong right) => left.Equals(right); public static bool operator !=(PointLong left, PointLong right) => !left.Equals(right); } } "),
new AclFileInfo(@"Util/Matrix.cs", new string[] { @"AtCoder.Util.Matrix" }, new string[] { @"using AtCoder.Algebra;", @"using System.Diagnostics;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"Algebra/Operators.cs" }, @"namespace AtCoder.Util { public static class Matrix { public static T[][] Pow<T, TOp>(T[][] mat, int y) where TOp : struct, IAddOperator<T>, IMultiplyOperator<T>, IIncrementOperator<T> { Debug.Assert(mat.Length == mat[0].Length); var K = mat.Length; T[][] res = NewArray<T>(K, K, default); var one = default(TOp).Increment(default); for (var i = 0; i < res.Length; i++) res[i][i] = one; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res = Mul<T, TOp>(res, mat); mat = Mul<T, TOp>(mat, mat); } return res; } public static T[][] Mul<T, TOp>(T[][] l, T[][] r) where TOp : struct, IAddOperator<T>, IMultiplyOperator<T> { var op = default(TOp); Debug.Assert(l[0].Length == r.Length); T[][] res = NewArray<T>(l.Length, r[0].Length, default); for (var i = 0; i < res.Length; i++) for (var j = 0; j < res[i].Length; j++) for (var k = 0; k < r.Length; k++) res[i][j] = op.Add(res[i][j], op.Multiply(l[i][k], r[k][j])); return res; } } } "),
new AclFileInfo(@"Util/PointDouble.cs", new string[] { @"AtCoder.Util.PointDouble" }, new string[] { @"using System;" }, new string[] {  }, @"namespace AtCoder.Util { public readonly struct PointDouble : IEquatable<PointDouble>, IComparable<PointDouble> { public readonly double x; public readonly double y; public PointDouble(double x, double y) { this.x = x; this.y = y; } [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public void Deconstruct(out double v1, out double v2) { v1 = x; v2 = y; } public static implicit operator PointDouble((double x, double y) tuple) => new PointDouble(tuple.x, tuple.y); public double Distance(PointDouble other) => Math.Sqrt(Distance2(other)); double Distance2(PointDouble other) { var p = other - this; return p.x * p.x + p.y * p.y; } public double Inner(PointDouble other) => x * other.x + y * other.y; public double Cross(PointDouble other) => x * other.y - y * other.x; public static PointDouble operator +(PointDouble a, PointDouble b) => new PointDouble(a.x + b.x, a.y + b.y); public static PointDouble operator -(PointDouble a, PointDouble b) => new PointDouble(a.x - b.x, a.y - b.y); public int CompareTo(PointDouble other) { var xd = this.x.CompareTo(other.x); if (xd != 0) return xd; return this.y.CompareTo(other.y); } public bool Equals(PointDouble other) => this.x == other.x && this.y == other.y; public override bool Equals(object obj) => obj is PointDouble p && this.Equals(p); public override int GetHashCode() => HashCode.Combine(x, y); public override string ToString() => $""({x}, {y})""; public static bool operator ==(PointDouble left, PointDouble right) => left.Equals(right); public static bool operator !=(PointDouble left, PointDouble right) => !left.Equals(right); public static PointDouble (PointDouble a, PointDouble b, PointDouble c) { var ab = a.Distance(b); var cb = c.Distance(b); var ac = a.Distance(c); var cosA = (ab * ab + ac * ac - cb * cb) / 2 / ab / ac; var cosB = (ab * ab + cb * cb - ac * ac) / 2 / ab / cb; var cosC = (cb * cb + ac * ac - ab * ab) / 2 / cb / ac; var d = cb * cosA + ac * cosB + ab * cosC; return new PointDouble(cb * cosA * a.x / d, cb * cosA * a.y / d) + new PointDouble(ac * cosB * b.x / d, ac * cosB * b.y / d) + new PointDouble(ab * cosC * c.x / d, ab * cosC * c.y / d); } public double (double A, double B, double C) => Math.Abs(A * x + B * y + C) / Math.Sqrt(A * A + B * B); public (double A, double B, double C) (PointDouble other) => (other.y - this.y, this.x - other.x, this.y * (other.x - this.x) - this.x * (other.y - this.y)); public static (double A, double B, double C) (PointDouble a, PointDouble b) => (a.x - b.x, a.y - b.y, (a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y) * -.5); public static PointDouble (double a, double b, double c, double u, double v, double w) { var dd = a * v - b * u; return new PointDouble((b * w - c * v) / dd, (c * u - a * w) / dd); } public static PointDouble[] (double a, double b, double c, PointDouble p, double r) { var l = a * a + b * b; var k = a * p.x + b * p.y + c; var d = l * r * r - k * k; if (d < 0) return Array.Empty<PointDouble>(); var apl = a / l; var bpl = b / l; var xc = p.x - apl * k; var yc = p.y - bpl * k; if (d == 0) return new[] { new PointDouble(xc, yc), }; var ds = Math.Sqrt(d); var xd = bpl * ds; var yd = apl * ds; return new[] { new PointDouble(xc - xd, yc + yd), new PointDouble(xc + xd, yc - yd), }; } public static PointDouble[] (PointDouble p1, double r1, PointDouble p2, double r2) { var xx = p1.x - p2.x; var yy = p1.y - p2.y; return ( xx, yy, 0.5 * ((r1 - r2) * (r1 + r2) - xx * (p1.x + p2.x) - yy * (p1.y + p2.y)), p1, r1); } public static bool (PointDouble a1, PointDouble b1, PointDouble a2, PointDouble b2) { var ta = (a2.x - b2.x) * (a1.y - a2.y) + (a2.y - b2.y) * (a2.x - a1.x); var tb = (a2.x - b2.x) * (b1.y - a2.y) + (a2.y - b2.y) * (a2.x - b1.x); var tc = (a1.x - b1.x) * (a2.y - a1.y) + (a1.y - b1.y) * (a1.x - a2.x); var td = (a1.x - b1.x) * (b2.y - a1.y) + (a1.y - b1.y) * (a1.x - b2.x); return tc * td < 0 && ta * tb < 0; } } }"),
new AclFileInfo(@"Bit/Bit.cs", new string[] { @"AtCoder.Bit", @"AtCoder.Bit.Enumerator" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using System.Numerics;", @"using Bmi1 = System.Runtime.Intrinsics.X86.Bmi1.X64;" }, new string[] {  }, @"namespace AtCoder { public static class Bit { public static string ToBitString(this int num, int padLeft = sizeof(int) * 8) => Convert.ToString(num, 2).PadLeft(padLeft, '0'); public static string ToBitString(this long num, int padLeft = sizeof(long) * 8) => Convert.ToString(num, 2).PadLeft(padLeft, '0'); public static string ToBitString(this ulong num, int padLeft = sizeof(ulong) * 8) => Convert.ToString(unchecked((long)num), 2).PadLeft(padLeft, '0'); public static bool On(this int num, int index) => ((num >> index) & 1) != 0; public static bool On(this long num, int index) => ((num >> index) & 1) != 0; public static bool On(this ulong num, int index) => ((num >> index) & 1) != 0; public static Enumerator Bits(this int num) => new Enumerator(num); public static Enumerator Bits(this uint num) => new Enumerator(num); public static Enumerator Bits(this long num) => new Enumerator(num); public static Enumerator Bits(this ulong num) => new Enumerator(num); public struct Enumerator : IEnumerable<int>, IEnumerator<int> { ulong num; public Enumerator(int num) : this((ulong)(uint)num) { } public Enumerator(long num) : this((ulong)num) { } public Enumerator(ulong num) { this.num = num; Current = -1; } public Enumerator GetEnumerator() => this; public int Current { get; private set; } public bool MoveNext() { if (num == 0) return false; if (Bmi1.IsSupported) { Current = unchecked((int)Bmi1.TrailingZeroCount(num)); num = Bmi1.ResetLowestSetBit(num); } else MoveNextLogical(); return true; } void MoveNextLogical() { var lsb1 = BitOperations.TrailingZeroCount(num) + 1; if (lsb1 == 64) num = 0; Current += lsb1; num >>= lsb1; } object IEnumerator.Current => Current; void IEnumerator.Reset() => throw new NotSupportedException(); void IDisposable.Dispose() { } IEnumerator<int> IEnumerable<int>.GetEnumerator() => this; IEnumerator IEnumerable.GetEnumerator() => this; } } }"),
new AclFileInfo(@"Graph/GraphUtil.cs", new string[] { @"AtCoder.Graph.GraphUtil", @"AtCoder.Graph.ShortestPathBFS" }, new string[] { @"using AtCoder;", @"using System;", @"using System.Collections.Generic;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"Graph/.cs" }, @"namespace AtCoder.Graph { public static class GraphUtil { public static int[] (this Node[] graph) { var sumi = new bool[graph.Length]; Span<int> Dfs1(int index, Span<int> jun) { if (sumi[index]) return jun; sumi[index] = true; foreach (var child in graph[index].children) { jun = Dfs1(child, jun); } jun[^1] = index; jun = jun[0..^1]; return jun; } var jun = new int[graph.Length]; var junsp = jun.AsSpan(); for (int i = 0; i < graph.Length; i++) junsp = Dfs1(i, junsp); var res = NewArray(graph.Length, -1); bool Dfs2(int index, int group) { if (res[index] >= 0) return false; res[index] = group; foreach (var r in graph[index].roots) Dfs2(r, group); return true; } var g = 0; foreach (var i in jun) if (Dfs2(i, g)) g++; return res; } public static int MaxFlow(this Node[] graph, int from, int to) { var capacities = new Dictionary<(int from, int to), int>(); for (int i = 0; i < graph.Length; i++) foreach (var next in graph[i].children) capacities.Add((i, next), 1); var children = new HashSet<int>[graph.Length]; for (int i = 0; i < children.Length; i++) children[i] = new HashSet<int>(graph[i].children); var ret = 0; while (true) { var routes = new (int from, int to)[children.Length][]; var queue = new Queue<int>(children.Length); routes[from] = Array.Empty<ValueTuple<int, int>>(); queue.Enqueue(from); while (queue.Count > 0 && routes[to] == null) { var cur = queue.Dequeue(); foreach (var child in children[cur]) { var route = (cur, child); if (routes[child] == null && capacities[route] > 0) { routes[child] = new (int from, int to)[routes[cur].Length + 1]; routes[cur].CopyTo(routes[child], 0); routes[child][^1] = route; queue.Enqueue(child); } } } if (routes[to] == null) return ret; var min = int.MaxValue; foreach (var route in routes[to]) min = Math.Min(min, capacities[route]); ret += min; foreach (var route in routes[to]) { capacities[route] -= min; var rev = (route.to, route.from); children[route.to].Add(route.from); capacities.TryGetValue(rev, out int v); capacities[rev] = v + min; } } } public static Node[] BFS(this Node[] graph) { var sumi = new bool[graph.Length]; var gb = new GraphBuilder(graph.Length, false); var queue = new Queue<int>(graph.Length); queue.Enqueue(0); sumi[0] = true; while (queue.Count > 0) { var cur = queue.Dequeue(); sumi[cur] = true; foreach (var child in graph[cur].children) { if (!sumi[child]) { sumi[child] = true; gb.Add(cur, child); queue.Enqueue(child); } } } return gb.ToArray(); } } public static class ShortestPathBFS { public static int[] BFS(this Node[] graph, int from) { var res = NewArray(graph.Length, int.MaxValue); var queue = new Queue<int>(); queue.Enqueue(from); res[from] = 0; while (queue.Count > 0) { var cur = queue.Dequeue(); foreach (var child in graph[cur].children) if (res[child].UpdateMin(res[cur] + 1)) queue.Enqueue(child); } return res; } } }"),
new AclFileInfo(@"Graph/.cs", new string[] { @"AtCoder.Graph.LowestCommonAncestor" }, new string[] { @"using System;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"Graph/.cs" }, @"namespace AtCoder.Graph { public class LowestCommonAncestor { readonly TreeNode[] tree; readonly int[][] kprv; readonly int logN; public LowestCommonAncestor(TreeNode[] tree) { if (tree.Length == 0) throw new ArgumentException(nameof(tree)); this.tree = tree; this.logN = MSB(tree.Length) + 1; this.kprv = NewArray(tree.Length, logN, 0); for (int v = 0; v < tree.Length; v++) { this.kprv[v][0] = tree[v].root; } for (int k = 0; k < logN - 1; k++) { for (int v = 0; v < tree.Length; v++) { if (this.kprv[v][k] < 0) this.kprv[v][k + 1] = -1; else this.kprv[v][k + 1] = this.kprv[this.kprv[v][k]][k]; } } } public int Lca(int u, int v) { if (Depth(u) > Depth(v)) { (u, v) = (v, u); } for (int k = 0; k <= logN; k++) { if ((((Depth(v) - Depth(u)) >> k) & 1) == 1) { v = kprv[v][k]; } } if (u == v) return u; for (int k = logN - 1; k >= 0; k--) { if (kprv[u][k] != kprv[v][k] && kprv[u][k] != -1 && kprv[v][k] != -1) { u = kprv[u][k]; v = kprv[v][k]; } } return kprv[u][0]; } int Depth(int index) => tree[index].depth; } }"),
new AclFileInfo(@"Graph/.cs", new string[] { @"AtCoder.Graph.GraphSearch", @"AtCoder.Graph.GraphSearch.BFSData" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] { @"Graph/.cs" }, @"namespace AtCoder.Graph { public class GraphSearch { enum Status { None, Active, Done } Node[] graph; Status[] statuses; public GraphSearch(Node[] graph) { this.graph = graph; this.statuses = new Status[graph.Length]; } public int[] GetCycleDFS() { for (var i = 0; i < graph.Length; i++) { if (statuses[i] == Status.None) { var res = GetCycleDFS(i); if (res != null) { res.Reverse(); return res.ToArray(); } } } return null; } List<int> GetCycleDFS(int v) { statuses[v] = Status.Active; foreach (var child in graph[v].children) { switch (statuses[child]) { case Status.None: var list = GetCycleDFS(child); if (list != null) { if (list.Count < 2 || list[0] != list[^1]) list.Add(v); return list; } break; case Status.Active: return new List<int> { child, v }; } } statuses[v] = Status.Done; return null; } class BFSData { public readonly int[] current; public readonly bool[] used; public BFSData(int[] current, bool[] used) { this.current = current; this.used = used; } } public int[] GetCycleBFS() { for (var i = 0; i < graph.Length; i++) { if (statuses[i] == Status.None) { var res = GetCycleBFS(i); if (res != null) return res; } } return null; } int[] GetCycleBFS(int v) { int[] res = null; statuses[v] = Status.Active; var queue = new Queue<BFSData>(); var bfsd = new BFSData(new[] { v }, new bool[graph.Length]); bfsd.used[v] = true; queue.Enqueue(bfsd); while (queue.Count > 0) { bfsd = queue.Dequeue(); foreach (var child in graph[bfsd.current[^1]].children) { if (bfsd.used[child]) { var index = Array.IndexOf(bfsd.current, child); if (res == null || res.Length > bfsd.current.Length + 1 - index) { res = new int[bfsd.current.Length + 1 - index]; Array.Copy(bfsd.current, index, res, 0, bfsd.current.Length - index); res[^1] = child; } } else if (res == null) { statuses[child] = Status.Done; var next = new int[bfsd.current.Length + 1]; Array.Copy(bfsd.current, next, bfsd.current.Length); next[^1] = child; var nextUsed = (bool[])bfsd.used.Clone(); nextUsed[child] = true; queue.Enqueue(new BFSData(next, nextUsed)); } } } return res; } } }"),
new AclFileInfo(@"Graph/.cs", new string[] { @"AtCoder.Graph.GraphBuilder", @"AtCoder.Graph.TreeNode", @"AtCoder.Graph.Node" }, new string[] { @"using AtCoder.IO;", @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] { @"IO/ConsoleReader.cs" }, @"namespace AtCoder.Graph { public class GraphBuilder { List<int>[] roots; List<int>[] children; public GraphBuilder(int count, bool isOriented) { this.roots = new List<int>[count]; this.children = new List<int>[count]; for (var i = 0; i < count; i++) { if (isOriented) { this.roots[i] = new List<int>(); this.children[i] = new List<int>(); } else { this.roots[i] = this.children[i] = new List<int>(); } } } public GraphBuilder(int count, ConsoleReader cr, int edgeCount, bool isOriented) : this(count, isOriented) { for (var i = 0; i < edgeCount; i++) this.Add(cr.Int0, cr.Int0); } public static TreeNode[] MakeTree(int count, ConsoleReader cr, int root = 0) => new GraphBuilder(count, cr, count - 1, false).ToTree(root); public void Add(int from, int to) { children[from].Add(to); roots[to].Add(from); } public TreeNode[] ToTree(int root = 0) { if (this.roots[0] != this.children[0]) throw new Exception(""""); var res = new TreeNode[this.children.Length]; res[root] = new TreeNode(root, -1, 0, this.children[root].ToArray()); var queue = new Queue<int>(); foreach (var child in res[root].children) { res[child] = new TreeNode(child, root, 1, Array.Empty<int>()); queue.Enqueue(child); } while (queue.Count > 0) { var from = queue.Dequeue(); if (res[from].root == -1) res[from].children = this.children[from].ToArray(); else { var children = new List<int>(this.children[from].Count); foreach (var c in this.children[from]) if (c != res[from].root) children.Add(c); res[from].children = children.ToArray(); } foreach (var child in res[from].children) { res[child] = new TreeNode(child, from, res[from].depth + 1, Array.Empty<int>()); queue.Enqueue(child); } } return res; } public Node[] ToArray() => Enumerable .Zip(roots, children, (root, child) => (root, child)) .Select((t, i) => new Node(i, t.root.ToArray(), t.child.ToArray())) .ToArray(); public GraphBuilder Clone() { var count = this.roots.Length; var isOriented = this.roots[0] != this.children[0]; var cl = new GraphBuilder(count, isOriented); for (int i = 0; i < count; i++) { if (isOriented) { cl.children[i] = this.children[i].ToList(); cl.roots[i] = this.roots[i].ToList(); } else cl.children[i] = cl.roots[i] = this.roots[i].ToList(); } return cl; } } public class TreeNode { public TreeNode(int i, int root, int depth, int[] children) { this.index = i; this.root = root; this.children = children; this.depth = depth; } public readonly int index; public readonly int root; public readonly int depth; public int[] children; public override string ToString() => $""children: {string.Join("","", children)}""; public override bool Equals(object obj) => obj is TreeNode node && this.Equals(node); public bool Equals(TreeNode other) => this.index == other.index; public override int GetHashCode() => this.index; } public class Node { public Node(int i, int[] roots, int[] children) { this.index = i; this.roots = roots; this.children = children; } public readonly int index; public readonly int[] roots; public readonly int[] children; public override string ToString() => $""children: {string.Join("","", children)}""; public override bool Equals(object obj) => obj is Node d && this.Equals(d); public bool Equals(Node other) => this.index == other.index; public override int GetHashCode() => this.index; } }"),
new AclFileInfo(@"IO/ConsoleWriter.cs", new string[] { @"AtCoder.IO.ConsoleWriter" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.IO;", @"using System.Text;" }, new string[] {  }, @"namespace AtCoder.IO { [DebuggerStepThrough] public class ConsoleWriter { [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly StreamWriter sw; public ConsoleWriter() : this(Console.OpenStandardOutput(), Console.OutputEncoding) { } public ConsoleWriter(Stream output, Encoding encoding) { sw = new StreamWriter(output, encoding); } public void Flush() => sw.Flush(); public ConsoleWriter WriteLine(ReadOnlySpan<char> obj) { sw.WriteLine(obj); return this; } public ConsoleWriter WriteLine<T>(T obj) { sw.WriteLine(obj.ToString()); return this; } public ConsoleWriter WriteLineJoin<T>(Span<T> col) => WriteMany(' ', (ReadOnlySpan<T>)col); public ConsoleWriter WriteLineJoin<T>(ReadOnlySpan<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(IEnumerable<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(params T[] col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin(params object[] col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T1, T2>(T1 v1, T2 v2) { sw.Write(v1.ToString()); sw.Write(' '); sw.WriteLine(v2.ToString()); return this; } public ConsoleWriter WriteLineJoin<T1, T2, T3>(T1 v1, T2 v2, T3 v3) { sw.Write(v1.ToString()); sw.Write(' '); sw.Write(v2.ToString()); sw.Write(' '); sw.WriteLine(v3.ToString()); return this; } public ConsoleWriter WriteLineJoin<T1, T2, T3, T4>(T1 v1, T2 v2, T3 v3, T4 v4) { sw.Write(v1.ToString()); sw.Write(' '); sw.Write(v2.ToString()); sw.Write(' '); sw.Write(v3.ToString()); sw.Write(' '); sw.WriteLine(v4.ToString()); return this; } public ConsoleWriter WriteLines<T>(Span<T> col) => WriteMany('\n', (ReadOnlySpan<T>)col); public ConsoleWriter WriteLines<T>(ReadOnlySpan<T> col) => WriteMany('\n', col); public ConsoleWriter WriteLines<T>(IEnumerable<T> col) => WriteMany('\n', col); public ConsoleWriter WriteLineGrid<T>(IEnumerable<IEnumerable<T>> cols) { foreach (var col in cols) WriteLineJoin(col); return this; } private ConsoleWriter WriteMany<T>(char sep, ReadOnlySpan<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } private ConsoleWriter WriteMany<T>(char sep, IEnumerable<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } } } "),
new AclFileInfo(@"IO/ConsoleReader.cs", new string[] { @"AtCoder.IO.ConsoleReader", @"AtCoder.IO.ConsoleReader.RepeatReader", @"AtCoder.IO.ConsoleReader.SplitReader" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.IO;", @"using System.Runtime.CompilerServices;", @"using System.Text;" }, new string[] {  }, @"namespace AtCoder.IO { [DebuggerStepThrough] public class ConsoleReader { const int BufSize = 1 << 12; private readonly byte[] buffer = new byte[BufSize]; private readonly Stream input; private readonly Encoding encoding; private int pos = 0; private int len = 0; public ConsoleReader(Stream input, Encoding encoding) { this.input = input; this.encoding = encoding; } public ConsoleReader() : this(Console.OpenStandardInput(), Console.InputEncoding) { } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void MoveNext() { if (++pos >= len) { len = input.Read(buffer, 0, buffer.Length); if (len == 0) { buffer[0] = 10; } pos = 0; } } public int Int { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { int res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public int Int0 => Int - 1; public long Long { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { long res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = res * 10 + (buffer[pos] ^ 48); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public long Long0 => Long - 1; public string String { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return encoding.GetString(sb.ToArray()); } } public string Ascii { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new StringBuilder(); while (buffer[pos] <= 32) MoveNext(); do { sb.Append((char)buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return sb.ToString(); } } public string Line { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (buffer[pos] != 10 && buffer[pos] != 13); return encoding.GetString(sb.ToArray()); } } public char Char { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { while (buffer[pos] <= 32) MoveNext(); char res = (char)buffer[pos]; MoveNext(); return res; } } public double Double => double.Parse(Ascii); [DebuggerStepThrough] public ref struct RepeatReader { readonly ConsoleReader cr; readonly int count; public RepeatReader(ConsoleReader cr, int count) { this.cr = cr; this.count = count; } public T[] Select<T>(Func<ConsoleReader, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr); return arr; } public T[] Select<T>(Func<ConsoleReader, int, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr, i); return arr; } public string[] Line { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Line; return arr; } } public string[] String { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.String; return arr; } } public string[] Ascii { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Ascii; return arr; } } public int[] Int { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int; return arr; } } public int[] Int0 { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int0; return arr; } } public long[] Long { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long; return arr; } } public long[] Long0 { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long0; return arr; } } public double[] Double { get { var arr = new double[count]; for (var i = 0; i < count; i++) arr[i] = cr.Double; return arr; } } public static implicit operator int[](RepeatReader rr) => rr.Int; public static implicit operator long[](RepeatReader rr) => rr.Long; public static implicit operator double[](RepeatReader rr) => rr.Double; public static implicit operator string[](RepeatReader rr) => rr.Ascii; } public RepeatReader Repeat(int count) => new RepeatReader(this, count); [DebuggerStepThrough] public ref struct SplitReader { readonly ConsoleReader cr; public SplitReader(ConsoleReader cr) { this.cr = cr; } public string[] String { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.String); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public string[] Ascii { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Ascii); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public double[] Double { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<double>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Double); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public static implicit operator int[](SplitReader sr) => sr.Int; public static implicit operator long[](SplitReader sr) => sr.Long; public static implicit operator double[](SplitReader sr) => sr.Double; public static implicit operator string[](SplitReader sr) => sr.Ascii; } public SplitReader Split => new SplitReader(this); public static implicit operator int(ConsoleReader cr) => cr.Int; public static implicit operator long(ConsoleReader cr) => cr.Long; public static implicit operator double(ConsoleReader cr) => cr.Double; public static implicit operator string(ConsoleReader cr) => cr.Ascii; } } "),
new AclFileInfo(@"GraphAcl/MaxFlow.cs", new string[] { @"AtCoder.GraphAcl.MFGraphInt", @"AtCoder.GraphAcl.MFGraphLong", @"AtCoder.GraphAcl.MFGraph<TValue, TOp>", @"AtCoder.GraphAcl.MFGraph<TValue, TOp>.Edge", @"AtCoder.GraphAcl.MFGraph<TValue, TOp>.EdgeInternal" }, new string[] { @"using AtCoder.Algebra;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder.GraphAcl { public class MFGraphInt : MFGraph<int, IntOperator> { public MFGraphInt(int n) : base(n) { } } public class MFGraphLong : MFGraph<long, LongOperator> { public MFGraphLong(int n) : base(n) { } } public class MFGraph<TValue, TOp> where TOp : ISignedNumOperator<TValue> { static readonly TOp op = default; public MFGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TValue cap) { int m = _pos.Count; Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); Debug.Assert(op.LessThanOrEqual(default, cap)); _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default)); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, op.Add(_e.Cap, _re.Cap), _re.Cap); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public void ChangeEdge(int i, TValue newCap, TValue newFlow) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); Debug.Assert(op.LessThanOrEqual(default, newFlow) && op.LessThanOrEqual(newFlow, newCap)); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; _e.Cap = op.Subtract(newCap, newFlow); _re.Cap = newFlow; } public TValue Flow(int s, int t) { return Flow(s, t, op.MaxValue); } public TValue Flow(int s, int t, TValue flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); var level = new int[_n]; var iter = new int[_n]; var que = new Queue<int>(); void Bfs() { for (int i = 0; i < _n; i++) { level[i] = -1; } level[s] = 0; que.Clear(); que.Enqueue(s); while (que.Count > 0) { int v = que.Dequeue(); foreach (var e in _g[v]) { if (op.Equals(e.Cap, default) || level[e.To] >= 0) continue; level[e.To] = level[v] + 1; if (e.To == t) return; que.Enqueue(e.To); } } } TValue Dfs(int v, TValue up) { if (v == s) return up; var res = default(TValue); int level_v = level[v]; for (; iter[v] < _g[v].Count; iter[v]++) { EdgeInternal e = _g[v][iter[v]]; if (level_v <= level[e.To] || op.Equals(_g[e.To][e.Rev].Cap, default)) continue; var up1 = op.Subtract(up, res); var up2 = _g[e.To][e.Rev].Cap; var d = Dfs(e.To, op.LessThan(up1, up2) ? up1 : up2); if (op.Compare(d, default) <= 0) continue; _g[v][iter[v]].Cap = op.Add(_g[v][iter[v]].Cap, d); _g[e.To][e.Rev].Cap = op.Subtract(_g[e.To][e.Rev].Cap, d); res = op.Add(res, d); if (res.Equals(up)) break; } return res; } TValue flow = default; while (op.LessThan(flow, flowLimit)) { Bfs(); if (level[t] == -1) break; for (int i = 0; i < _n; i++) { iter[i] = 0; } while (op.LessThan(flow, flowLimit)) { var f = Dfs(t, op.Subtract(flowLimit, flow)); if (op.Equals(f, default)) break; flow = op.Add(flow, f); } } return flow; } public bool[] MinCut(int s) { var visited = new bool[_n]; var que = new Queue<int>(); que.Enqueue(s); while (que.Count > 0) { int p = que.Dequeue(); visited[p] = true; foreach (var e in _g[p]) { if (!op.Equals(e.Cap, default) && !visited[e.To]) { visited[e.To] = true; que.Enqueue(e.To); } } } return visited; } public struct Edge { public int From { get; set; } public int To { get; set; } public TValue Cap { get; set; } public TValue Flow { get; set; } public Edge(int from, int to, TValue cap, TValue flow) { From = from; To = to; Cap = cap; Flow = flow; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TValue Cap { get; set; } public EdgeInternal(int to, int rev, TValue cap) { To = to; Rev = rev; Cap = cap; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; } } "),
new AclFileInfo(@"GraphAcl/TwoSat.cs", new string[] { @"AtCoder.GraphAcl.TwoSat" }, new string[] { @"using System.Diagnostics;" }, new string[] { @"GraphAcl/SCCGraph.cs" }, @"namespace AtCoder.GraphAcl { [DebuggerDisplay(""Count = {_n}"")] public class TwoSat { readonly int _n; readonly private bool[] _answer; readonly private SCCGraph scc; public TwoSat(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _n = n; _answer = new bool[n]; scc = new SCCGraph(2 * n); } public void AddClause(int i, bool f, int j, bool g) { Debug.Assert(unchecked((uint)i < _n)); Debug.Assert(unchecked((uint)j < _n)); scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0)); scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0)); } public bool Satisfiable() { var sccs = scc.SCC(); var id = new int[2 * _n]; for (int i = 0; i < sccs.Count; i++) { foreach (var v in sccs[i]) { id[v] = i; } } for (int i = 0; i < _n; i++) { if (id[2 * i] == id[2 * i + 1]) { return false; } else { _answer[i] = id[2 * i] < id[2 * i + 1]; } } return true; } public bool[] Answer() => _answer; } } "),
new AclFileInfo(@"GraphAcl/MinCostFlow.cs", new string[] { @"AtCoder.GraphAcl.ICastOperator<TFrom, TTo>", @"AtCoder.GraphAcl.SameTypeCastOperator<T>", @"AtCoder.GraphAcl.IntToLongCastOperator", @"AtCoder.GraphAcl.McfGraphInt", @"AtCoder.GraphAcl.McfGraphLong", @"AtCoder.GraphAcl.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>", @"AtCoder.GraphAcl.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.Edge", @"AtCoder.GraphAcl.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.EdgeInternal", @"AtCoder.GraphAcl.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.PriorityQueueForMcf" }, new string[] { @"using AtCoder.Algebra;", @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Runtime.CompilerServices;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder.GraphAcl { public interface ICastOperator<TFrom, TTo> where TFrom : struct where TTo : struct { TTo Cast(TFrom y); } public struct SameTypeCastOperator<T> : ICastOperator<T, T> where T : struct { public T Cast(T y) => y; } public struct IntToLongCastOperator : ICastOperator<int, long> { public long Cast(int y) => y; } public class McfGraphInt : McfGraph<int, IntOperator, int, IntOperator, SameTypeCastOperator<int>> { public McfGraphInt(int n) : base(n) { } } public class McfGraphLong : McfGraph<long, LongOperator, long, LongOperator, SameTypeCastOperator<long>> { public McfGraphLong(int n) : base(n) { } } public class McfGraph<TCap, TCapOp, TCost, TCostOp, TCast> where TCap : struct where TCapOp : struct, ISignedNumOperator<TCap> where TCost : struct where TCostOp : struct, ISignedNumOperator<TCost> where TCast : ICastOperator<TCap, TCost> { static readonly TCapOp capOp = default; static readonly TCostOp costOp = default; static readonly TCast cast = default; public McfGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TCap cap, TCost cost) { Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); int m = _pos.Count; _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap, cost)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default, costOp.Negate(cost))); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, capOp.Add(_e.Cap, _re.Cap), _re.Cap, _e.Cost); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public (TCap cap, TCost cost) Flow(int s, int t) { return Flow(s, t, capOp.MaxValue); } public (TCap cap, TCost cost) Flow(int s, int t, TCap flowLimit) { return Slope(s, t, flowLimit).Last(); } public List<(TCap cap, TCost cost)> Slope(int s, int t) { return Slope(s, t, capOp.MaxValue); } public List<(TCap cap, TCost cost)> Slope(int s, int t, TCap flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); Debug.Assert(s != t); var dual = new TCost[_n]; var dist = new TCost[_n]; var pv = new int[_n]; var pe = new int[_n]; var vis = new bool[_n]; bool DualRef() { dist.AsSpan().Fill(costOp.MaxValue); pv.AsSpan().Fill(-1); pe.AsSpan().Fill(-1); vis.AsSpan().Fill(false); var que = new PriorityQueueForMcf(); dist[s] = default; que.Enqueue(default, s); while (que.Count > 0) { int v = que.Dequeue().to; if (vis[v]) continue; vis[v] = true; if (v == t) break; for (int i = 0; i < _g[v].Count; i++) { var e = _g[v][i]; if (vis[e.To] || capOp.Equals(e.Cap, default)) continue; TCost cost = costOp.Add(costOp.Subtract(e.Cost, dual[e.To]), dual[v]); if (costOp.GreaterThan(costOp.Subtract(dist[e.To], dist[v]), cost)) { dist[e.To] = costOp.Add(dist[v], cost); pv[e.To] = v; pe[e.To] = i; que.Enqueue(dist[e.To], e.To); } } } if (!vis[t]) { return false; } for (int v = 0; v < _n; v++) { if (!vis[v]) continue; dual[v] = costOp.Subtract(dual[v], costOp.Subtract(dist[t], dist[v])); } return true; } TCap flow = default; TCost cost = default; TCost prev_cost = costOp.Decrement(default); var result = new List<(TCap cap, TCost cost)> { (flow, cost) }; while (capOp.LessThan(flow, flowLimit)) { if (!DualRef()) break; TCap c = capOp.Subtract(flowLimit, flow); for (int v = t; v != s; v = pv[v]) { if (capOp.LessThan(_g[pv[v]][pe[v]].Cap, c)) { c = _g[pv[v]][pe[v]].Cap; } } for (int v = t; v != s; v = pv[v]) { _g[pv[v]][pe[v]].Cap = capOp.Subtract(_g[pv[v]][pe[v]].Cap, c); _g[v][_g[pv[v]][pe[v]].Rev].Cap = capOp.Add(_g[v][_g[pv[v]][pe[v]].Rev].Cap, c); } TCost d = costOp.Negate(dual[s]); flow = capOp.Add(flow, c); cost = costOp.Add(cost, costOp.Multiply(cast.Cast(c), d)); if (costOp.Equals(prev_cost, d)) { result.RemoveAt(result.Count - 1); } result.Add((flow, cost)); prev_cost = cost; } return result; } public struct Edge { public int From { get; set; } public int To { get; set; } public TCap Cap { get; set; } public TCap Flow { get; set; } public TCost Cost { get; set; } public Edge(int from, int to, TCap cap, TCap flow, TCost cost) { From = from; To = to; Cap = cap; Flow = flow; Cost = cost; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TCap Cap { get; set; } public TCost Cost { get; set; } public EdgeInternal(int to, int rev, TCap cap, TCost cost) { To = to; Rev = rev; Cap = cap; Cost = cost; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; private class PriorityQueueForMcf { private (TCost cost, int to)[] _heap; public int Count { get; private set; } = 0; public PriorityQueueForMcf() { _heap = new (TCost cost, int to)[1024]; } public void Enqueue(TCost cost, int to) { var pair = (cost, to); if (_heap.Length == Count) { var newHeap = new (TCost cost, int to)[_heap.Length * 2]; _heap.CopyTo(newHeap, 0); _heap = newHeap; } _heap[Count] = pair; ++Count; int c = Count - 1; while (c > 0) { int p = (c - 1) >> 1; if (Compare(_heap[p].cost, cost) < 0) { _heap[c] = _heap[p]; c = p; } else { break; } } _heap[c] = pair; } public (TCost cost, int to) Dequeue() { (TCost cost, int to) ret = _heap[0]; int n = Count - 1; var item = _heap[n]; int p = 0; int c = (p << 1) + 1; while (c < n) { if (c != n - 1 && Compare(_heap[c + 1].cost, _heap[c].cost) > 0) { ++c; } if (Compare(item.cost, _heap[c].cost) < 0) { _heap[p] = _heap[c]; p = c; c = (p << 1) + 1; } else { break; } } _heap[p] = item; Count--; return ret; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int Compare(TCost x, TCost y) => costOp.Compare(y, x); } } } "),
new AclFileInfo(@"GraphAcl/DSU.cs", new string[] { @"AtCoder.GraphAcl.DSU" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] {  }, @"namespace AtCoder.GraphAcl { public class DSU { public int Count { get; } private readonly int[] ParentOrSize; public DSU(int n) { Count = n; ParentOrSize = new int[n]; for (int i = 0; i < ParentOrSize.Length; i++) ParentOrSize[i] = -1; } public bool Merge(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); int x = Leader(a), y = Leader(b); if (x == y) return false; if (-ParentOrSize[x] < -ParentOrSize[y]) (x, y) = (y, x); ParentOrSize[x] += ParentOrSize[y]; ParentOrSize[y] = x; return true; } public bool Same(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); return Leader(a) == Leader(b); } public int Leader(int a) { if (ParentOrSize[a] < 0) return a; while (0 <= ParentOrSize[ParentOrSize[a]]) { (a, ParentOrSize[a]) = (ParentOrSize[a], ParentOrSize[ParentOrSize[a]]); } return ParentOrSize[a]; } public int Size(int a) { Debug.Assert(0 <= a && a < Count); return -ParentOrSize[Leader(a)]; } public int[][] Groups() { int[] leaderBuf = new int[Count]; int[] id = new int[Count]; var result = new List<int[]>(Count); int groupCount = 0; for (int i = 0; i < leaderBuf.Length; i++) { leaderBuf[i] = Leader(i); if (i == leaderBuf[i]) { id[i] = groupCount++; result.Add(new int[-ParentOrSize[i]]); } } int[] ind = new int[groupCount]; for (int i = 0; i < leaderBuf.Length; i++) { var leaderID = id[leaderBuf[i]]; result[leaderID][ind[leaderID]++] = i; } return result.ToArray(); } } } "),
new AclFileInfo(@"GraphAcl/SCCGraph.cs", new string[] { @"AtCoder.GraphAcl.SCCGraph" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"GraphAcl/Internal/InternalSCCGraph.cs" }, @"namespace AtCoder.GraphAcl { [DebuggerDisplay(""Vertices = {_internal._n}, Edges = {_internal.edges.Count}"")] public class SCCGraph { readonly Internal.SCCGraph _internal; public SCCGraph(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _internal = new Internal.SCCGraph(n); } public void AddEdge(int from, int to) { int n = _internal.VerticesNumbers; Debug.Assert(unchecked((uint)from < n)); Debug.Assert(unchecked((uint)to < n)); _internal.AddEdge(from, to); } public List<List<int>> SCC() => _internal.SCC(); } } "),
new AclFileInfo(@"DataStructure/String/ZAlgorithm.cs", new string[] { @"AtCoder.DataStructure.String.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.DataStructure.String { public static partial class StringLib { public static int[] ZAlgorithm<T>(ReadOnlySpan<T> s) { int n = s.Length; if (n == 0) return Array.Empty<int>(); int[] z = new int[n]; z[0] = 0; for (int i = 1, j = 0; i < n; i++) { ref int k = ref z[i]; k = (j + z[j] <= i) ? 0 : Math.Min(j + z[j] - i, z[i - j]); while (i + k < n && EqualityComparer<T>.Default.Equals(s[k], s[i + k])) k++; if (j + z[j] < i + z[i]) j = i; } z[0] = n; return z; } public static int[] ZAlgorithm(string s) => ZAlgorithm(s.AsSpan()); public static int[] ZAlgorithm<T>(T[] s) => ZAlgorithm((ReadOnlySpan<T>)s); } } "),
new AclFileInfo(@"DataStructure/String/Trie.cs", new string[] { @"AtCoder.DataStructure.String.Trie<TKey, TValue>", @"AtCoder.DataStructure.String.Trie<TKey, TValue>.MatchEnumerator", @"AtCoder.DataStructure.String.Trie<T>" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] { @"Extensions.cs" }, @"namespace AtCoder.DataStructure.String { public class Trie<TKey, TValue> { readonly Dictionary<TKey, Trie<TKey, TValue>> children; public bool HasValue { private set; get; } TValue _Value; public TValue Value { set { _Value = value; HasValue = true; } get => _Value; } public Trie() : this(EqualityComparer<TKey>.Default) { } public Trie(IEqualityComparer<TKey> comparer) { children = new Dictionary<TKey, Trie<TKey, TValue>>(comparer); } public Trie<TKey, TValue> Next(TKey key) => children.Get(key); public Trie<TKey, TValue> GetChild(ReadOnlySpan<TKey> key, bool force = false) { var trie = this; foreach (var k in key) { var child = trie.Next(k); if (child == null) { if (!force) return null; child = trie.children[k] = new Trie<TKey, TValue>(trie.children.Comparer); } trie = child; } return trie; } public void Add(ReadOnlySpan<TKey> key, TValue value) => GetChild(key, true).Value = value; public bool Remove(ReadOnlySpan<TKey> key) { var stack = new Stack<(TKey k, Trie<TKey, TValue> trie)>(key.Length + 1); var trie = this; stack.Push((default, trie)); foreach (var k in key) { trie = trie.Next(k); if (trie == null) return false; stack.Push((k, trie)); } var cur = stack.Pop(); if (!cur.trie.HasValue) return false; cur.trie.HasValue = false; while (stack.Count > 0 && !cur.trie.HasValue && cur.trie.children.Count == 0) { var prevK = cur.k; cur = stack.Pop(); cur.trie.children.Remove(prevK); } return true; } public TValue Get(ReadOnlySpan<TKey> key) { if (TryGet(key, out var val)) return val; throw new KeyNotFoundException(); } public bool TryGet(ReadOnlySpan<TKey> key, out TValue value) { var child = GetChild(key); if (child == null || !child.HasValue) { value = default; return false; } value = child.Value; return true; } IEnumerable<KeyValuePair<TKey[], TValue>> All(List<TKey> list) { if (this.HasValue) yield return KeyValuePair.Create(list.ToArray(), this.Value); foreach (var (k, trie) in children) { list.Add(k); foreach (var p in trie.All(list)) yield return p; list.RemoveAt(list.Count - 1); } } public IEnumerable<KeyValuePair<TKey[], TValue>> All() => All(new List<TKey>()); public MatchEnumerator MatchGreedy(ReadOnlySpan<TKey> key) => new MatchEnumerator(this, key); public ref struct MatchEnumerator { Trie<TKey, TValue> trie; readonly ReadOnlySpan<TKey> span; public MatchEnumerator Current => this; int len; TValue value; public MatchEnumerator(Trie<TKey, TValue> trie, ReadOnlySpan<TKey> span) { this.trie = trie; this.span = span; len = -1; value = default; } public bool MoveNext() { bool ok = false; while (trie != null && !ok) { if (trie.HasValue) { value = trie.Value; ok = true; } if (len + 1 < span.Length) trie = trie.Next(span[++len]); else { ++len; trie = null; } } return ok; } public MatchEnumerator GetEnumerator() => this; public void Deconstruct(out ReadOnlySpan<TKey> key, out TValue value) { key = span[..len]; value = this.value; } } } class Trie<T> : Trie<T, bool> { public Trie() : base() { } public Trie(IEqualityComparer<T> comparer) : base(comparer) { } public void Add(ReadOnlySpan<T> key) => Add(key, true); public bool Contains(ReadOnlySpan<T> key) => GetChild(key) != null; } }"),
new AclFileInfo(@"DataStructure/String/RollingHash.cs", new string[] { @"AtCoder.DataStructure.String.RollingHash", @"AtCoder.DataStructure.String.RollingHash.Hash", @"AtCoder.DataStructure.String.RollingHash.RollingHashUInt64", @"AtCoder.DataStructure.String.RollingHash.RollingHashFast" }, new string[] { @"using System;" }, new string[] {  }, @"namespace AtCoder.DataStructure.String { public class RollingHash { static readonly Random rnd = new Random(); public struct Hash : IEquatable<Hash> { public ulong a; public ulong b; public override bool Equals(object obj) => obj is Hash h && Equals(h); public bool Equals(Hash other) => this.a == other.a && this.b == other.b; public static bool operator ==(Hash hash1, Hash hash2) => hash1.Equals(hash2); public static bool operator !=(Hash hash1, Hash hash2) => !hash1.Equals(hash2); public override int GetHashCode() => HashCode.Combine(a, b); } public RollingHashUInt64 hash1; public RollingHashFast hash2; public int Length { get; } public RollingHash(ReadOnlySpan<char> s) { this.Length = s.Length; hash1 = new RollingHashUInt64(s); hash2 = new RollingHashFast(s); } public Hash Slice(int from, int len) => new Hash { a = hash1.Slice(from, len), b = hash2.Slice(from, len) }; public class RollingHashUInt64 { static readonly uint B = (uint)rnd.Next(129, int.MaxValue); public readonly ulong[] pow; public readonly ulong[] hash; public int Length { get; } public RollingHashUInt64(ReadOnlySpan<char> s) { this.Length = s.Length; pow = new ulong[s.Length + 1]; pow[0] = 1; for (int i = 0; i < s.Length; i++) pow[i + 1] = pow[i] * B; hash = new ulong[s.Length + 1]; for (int i = 0; i < s.Length; i++) hash[i + 1] = hash[i] * B + s[i]; } public ulong Slice(int from, int len) => hash[from + len] - (hash[from] * pow[len]); } public class RollingHashFast { const int MAX_LENGTH = 500000; const ulong MASK30 = (1UL << 30) - 1; const ulong MASK31 = (1UL << 31) - 1; const ulong MOD = (1UL << 61) - 1; const ulong POSITIVIZER = MOD * ((1UL << 3) - 1); static readonly uint Base = (uint)rnd.Next(129, int.MaxValue); static readonly ulong[] powMemo = new ulong[MAX_LENGTH + 1]; static RollingHashFast() { powMemo[0] = 1; for (int i = 1; i < powMemo.Length; i++) powMemo[i] = CalcMod(Mul(powMemo[i - 1], Base)); } readonly ulong[] hash; public int Length { get; } public RollingHashFast(ReadOnlySpan<char> s) { this.Length = s.Length; hash = new ulong[s.Length + 1]; for (int i = 0; i < s.Length; i++) hash[i + 1] = CalcMod(Mul(hash[i], Base) + s[i]); } public ulong Slice(int from, int len) => CalcMod(hash[from + len] + POSITIVIZER - Mul(hash[from], powMemo[len])); static ulong Mul(ulong l, ulong r) { var lu = l >> 31; var ld = l & MASK31; var ru = r >> 31; var rd = r & MASK31; var middleBit = ld * ru + lu * rd; return ((lu * ru) << 1) + ld * rd + ((middleBit & MASK30) << 31) + (middleBit >> 30); } static ulong Mul(ulong l, uint r) { var lu = l >> 31; var rd = r & MASK31; var middleBit = lu * rd; return (l & MASK31) * rd + ((middleBit & MASK30) << 31) + (middleBit >> 30); } static ulong CalcMod(ulong val) { val = (val & MOD) + (val >> 61); if (val >= MOD) val -= MOD; return val; } } } }"),
new AclFileInfo(@"DataStructure/String/SuffixArray.cs", new string[] { @"AtCoder.DataStructure.String.SuffixArray", @"AtCoder.DataStructure.String.SuffixArray.SparseTableRMQ" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] { @"Global.cs" }, @"namespace AtCoder.DataStructure.String { public class SuffixArray { readonly int N; readonly int[] S; readonly int[] SA; readonly int[] rank; SparseTableRMQ rmq; public static SuffixArray Create<T>(IEnumerable<T> str) where T : IComparable<T> => new SuffixArray(Global.Compressed(str.ToArray())); public static SuffixArray Create<T>(T[] str) where T : IComparable<T> => new SuffixArray(Global.Compressed(str)); public SuffixArray(int[] S) { this.S = S; N = S.Length; SA = Sais(S, S.Max()); rank = new int[N + 1]; for (int i = 0; i <= N; i++) rank[SA[i]] = i; BuildLCP(); } static void CreateBeginBucket(int[] v, int[] b) { for (int i = 0; i < b.Length; i++) b[i] = 0; for (int i = 0; i < v.Length; i++) b[v[i]]++; int sum = 0; for (int i = 0; i < b.Length; i++) { b[i] += sum; var tmp = b[i]; b[i] = sum; sum = tmp; } } static void CreateEndBucket(int[] v, int[] b) { for (int i = 0; i < b.Length; i++) b[i] = 0; for (int i = 0; i < v.Length; i++) b[v[i]]++; for (int i = 1; i < b.Length; i++) b[i] += b[i - 1]; } static void InducedSort(int[] v, int[] sa, int[] b, bool[] isl) { CreateBeginBucket(v, b); for (int i = 0; i < v.Length; i++) if (sa[i] > 0 && isl[sa[i] - 1]) sa[b[v[sa[i] - 1]]++] = sa[i] - 1; } static void InvertInducedSort(int[] v, int[] sa, int[] b, bool[] isl) { CreateEndBucket(v, b); for (int i = v.Length - 1; i >= 0; i--) if (sa[i] > 0 && !isl[sa[i] - 1]) sa[--b[v[sa[i] - 1]]] = sa[i] - 1; } static int[] Sais(int[] v, int mv) { if (v.Length == 1) return new int[] { 0 }; var isl = new bool[v.Length]; var b = new int[mv + 1]; var sa = new int[v.Length]; for (int i = 0; i < v.Length; i++) sa[i] = -1; for (int i = v.Length - 2; i >= 0; i--) isl[i] = v[i] > v[i + 1] || (v[i] == v[i + 1] && isl[i + 1]); CreateEndBucket(v, b); for (int i = 0; i < v.Length; i++) if (IsLMS(i, isl)) sa[--b[v[i]]] = i; InducedSort(v, sa, b, isl); InvertInducedSort(v, sa, b, isl); var cur = 0; var ord = new int[v.Length]; for (int i = 0; i < v.Length; i++) if (IsLMS(i, isl)) ord[i] = cur++; var next = new int[cur]; cur = -1; int prev = -1; for (int i = 0; i < v.Length; i++) { if (!IsLMS(sa[i], isl)) continue; var diff = false; for (int d = 0; d < v.Length; d++) { if (prev == -1 || v[sa[i] + d] != v[prev + d] || isl[sa[i] + d] != isl[prev + d]) { diff = true; break; } else if (d > 0 && IsLMS(sa[i] + d, isl)) break; } if (diff) { cur++; prev = sa[i]; } next[ord[sa[i]]] = cur; } var reord = new int[next.Length]; for (int i = 0; i < v.Length; i++) if (IsLMS(i, isl)) reord[ord[i]] = i; var nextsa = Sais(next, cur); CreateEndBucket(v, b); for (int i = 0; i < sa.Length; i++) sa[i] = -1; for (int i = nextsa.Length - 1; i >= 0; i--) sa[--b[v[reord[nextsa[i]]]]] = reord[nextsa[i]]; InducedSort(v, sa, b, isl); InvertInducedSort(v, sa, b, isl); return sa; } static bool IsLMS(int x, bool[] isl) { return x > 0 && isl[x - 1] && !isl[x]; } void BuildLCP() { var k = 0; var h = new int[N]; for (int i = 0; i < N; i++) { var j = SA[rank[i] - 1]; if (k > 0) k--; for (; j + k < N && i + k < N; k++) if (S[j + k] != S[i + k]) break; h[rank[i] - 1] = k; } rmq = new SparseTableRMQ(h); } public int GetLCP(int i, int j) { i = rank[i]; j = rank[j]; return rmq.Query(Math.Min(i, j), Math.Max(i, j)); } public int this[int index] => index == 0 ? N : SA[index - 1]; public int Rank(int index) => rank[index]; public class SparseTableRMQ { readonly int n; readonly int[] A; public SparseTableRMQ(int[] a) { var k = 1; n = a.Length; for (int i = 1; i < n; i <<= 1) k++; A = new int[n * k]; for (int i = 0; i < n; i++) A[i] = a[i]; var d = 0; for (int i = 1; i < n; i <<= 1, d += n) { for (int j = 0; j < n; j++) A[d + n + j] = A[d + j]; for (int j = 0; j < n - i; j++) A[d + n + j] = Math.Min(A[d + j], A[d + j + i]); } } public int Query(int l, int r) { r--; int z = r - l, k = 0, e = 1, s; s = ((z & 0xffff0000) != 0 ? 1 : 0) << 4; z >>= s; e <<= s; k |= s; s = ((z & 0x0000ff00) != 0 ? 1 : 0) << 3; z >>= s; e <<= s; k |= s; s = ((z & 0x000000f0) != 0 ? 1 : 0) << 2; z >>= s; e <<= s; k |= s; s = ((z & 0x0000000c) != 0 ? 1 : 0) << 1; z >>= s; e <<= s; k |= s; s = ((z & 0x00000002) != 0 ? 1 : 0) << 0; e <<= s; k |= s; return Math.Min(A[l + (n * k)], A[r + (n * k) - e + 1]); } } } }"),
new AclFileInfo(@"DataStructure/String/SuffixArrayStatic.cs", new string[] { @"AtCoder.DataStructure.String.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.DataStructure.String { public static partial class StringLib { public static int[] LCPArray<T>(ReadOnlySpan<T> s, int[] sa) { Debug.Assert(1 <= s.Length); int[] rnk = new int[s.Length]; for (int i = 0; i < s.Length; i++) { rnk[sa[i]] = i; } int[] lcp = new int[s.Length - 1]; int h = 0; for (int i = 0; i < s.Length; i++) { if (h > 0) h--; if (rnk[i] == 0) continue; int j = sa[rnk[i] - 1]; for (; j + h < s.Length && i + h < s.Length; h++) { if (!EqualityComparer<T>.Default.Equals(s[j + h], s[i + h])) break; } lcp[rnk[i] - 1] = h; } return lcp; } public static int[] LCPArray(string s, int[] sa) => LCPArray(s.AsSpan(), sa); public static int[] LCPArray<T>(T[] s, int[] sa) => LCPArray((ReadOnlySpan<T>)s, sa); private static int[] SuffixArrayStatic<T>(ReadOnlyMemory<T> m) { var s = m.Span; var n = m.Length; var idx = Enumerable.Range(0, n).ToArray(); Array.Sort(idx, Compare); var s2 = new int[n]; var now = 0; for (int i = 0; i < idx.Length; i++) { if (i > 0 && !EqualityComparer<T>.Default.Equals(s[idx[i - 1]], s[idx[i]])) { now++; } s2[idx[i]] = now; } return SAIS(s2, now); int Compare(int l, int r) { var s = m.Span; return Comparer<T>.Default.Compare(s[l], s[r]); } } public static int[] SuffixArrayStatic(string s) { var n = s.Length; int[] s2 = s.Select(c => (int)c).ToArray(); return SAIS(s2, char.MaxValue); } public static int[] SuffixArrayStatic<T>(T[] s) => SuffixArrayStatic<T>(s.AsMemory()); public static int[] SuffixArrayStatic(int[] s, int upper) { Debug.Assert(0 <= upper); foreach (var si in s) { Debug.Assert(unchecked((uint)si) <= upper); } return SAIS(s, upper); } private static int[] SANaive(ReadOnlyMemory<int> sm) { var n = sm.Length; var sa = Enumerable.Range(0, n).ToArray(); Array.Sort(sa, Compare); return sa; int Compare(int l, int r) { var s = sm.Span; while (l < s.Length && r < s.Length) { if (s[l] != s[r]) { return s[l] - s[r]; } l++; r++; } return r - l; } } private static int[] SADoubling(ReadOnlyMemory<int> sm) { var s = sm.Span; var n = s.Length; var sa = Enumerable.Range(0, n).ToArray(); var rnk = new int[n]; var tmp = new int[n]; s.CopyTo(rnk); for (int k = 1; k < n; k <<= 1) { Array.Sort(sa, Compare); tmp[sa[0]] = 0; for (int i = 1; i < sa.Length; i++) { tmp[sa[i]] = tmp[sa[i - 1]] + (Compare(sa[i - 1], sa[i]) < 0 ? 1 : 0); } (tmp, rnk) = (rnk, tmp); int Compare(int x, int y) { if (rnk[x] != rnk[y]) { return rnk[x] - rnk[y]; } int rx = x + k < n ? rnk[x + k] : -1; int ry = y + k < n ? rnk[y + k] : -1; return rx - ry; } } return sa; } private static int[] SAIS(ReadOnlyMemory<int> sm, int upper) => SAIS(sm, upper, 10, 40); private static int[] SAIS(ReadOnlyMemory<int> sm, int upper, int thresholdNaive, int thresholdDouling) { var s = sm.Span; var n = s.Length; if (n == 0) { return Array.Empty<int>(); } else if (n == 1) { return new int[] { 0 }; } else if (n == 2) { if (s[0] < s[1]) { return new int[] { 0, 1 }; } else { return new int[] { 1, 0 }; } } else if (n < thresholdNaive) { return SANaive(sm); } else if (n < thresholdDouling) { return SADoubling(sm); } var sa = new int[n]; var ls = new bool[n]; for (int i = sa.Length - 2; i >= 0; i--) { ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]); } var sumL = new int[upper + 1]; var sumS = new int[upper + 1]; for (int i = 0; i < s.Length; i++) { if (!ls[i]) { sumS[s[i]]++; } else { sumL[s[i] + 1]++; } } for (int i = 0; i < sumL.Length; i++) { sumS[i] += sumL[i]; if (i < upper) { sumL[i + 1] += sumS[i]; } } var lmsMap = GetFilledArray(-1, n + 1); int m = 0; for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lmsMap[i] = m++; } } var lms = new List<int>(m); for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lms.Add(i); } } Induce(lms); if (m > 0) { var sortedLms = new List<int>(m); foreach (var v in sa) { if (lmsMap[v] != -1) { sortedLms.Add(v); } } var recS = new int[m]; var recUpper = 0; recS[lmsMap[sortedLms[0]]] = 0; for (int i = 1; i < sortedLms.Count; i++) { var l = sortedLms[i - 1]; var r = sortedLms[i]; var endL = (lmsMap[l] + 1 < m) ? lms[lmsMap[l] + 1] : n; var endR = (lmsMap[r] + 1 < m) ? lms[lmsMap[r] + 1] : n; var same = true; if (endL - l != endR - r) { same = false; } else { while (l < endL) { if (s[l] != s[r]) { break; } l++; r++; } if (l == n || s[l] != s[r]) { same = false; } } if (!same) { recUpper++; } recS[lmsMap[sortedLms[i]]] = recUpper; } var recSA = SAIS(recS, recUpper, thresholdNaive, thresholdDouling); for (int i = 0; i < sortedLms.Count; i++) { sortedLms[i] = lms[recSA[i]]; } Induce(sortedLms); } return sa; void Induce(List<int> lms) { var s = sm.Span; sa.AsSpan().Fill(-1); var buf = new int[sumS.Length]; sumS.AsSpan().CopyTo(buf); foreach (var d in lms) { if (d == n) { continue; } sa[buf[s[d]]++] = d; } sumL.AsSpan().CopyTo(buf); sa[buf[s[n - 1]]++] = n - 1; for (int i = 0; i < sa.Length; i++) { int v = sa[i]; if (v >= 1 && !ls[v - 1]) { sa[buf[s[v - 1]]++] = v - 1; } } sumL.AsSpan().CopyTo(buf); for (int i = sa.Length - 1; i >= 0; i--) { int v = sa[i]; if (v >= 1 && ls[v - 1]) { sa[--buf[s[v - 1] + 1]] = v - 1; } } } } private static T[] GetFilledArray<T>(T value, int length) { var result = new T[length]; result.AsSpan().Fill(value); return result; } } } "),
new AclFileInfo(@"DataStructure/String/BM.cs", new string[] { @"AtCoder.DataStructure.String.BoyerMoore" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.DataStructure.String { public class BoyerMoore { readonly string pattern; readonly Dictionary<char, int> table; public BoyerMoore(string pattern) { this.pattern = pattern; table = CreateTable(pattern); } static Dictionary<char, int> CreateTable(string pattern) { var table = new Dictionary<char, int>(); for (int i = 0; i < pattern.Length; i++) { table[pattern[i]] = pattern.Length - i - 1; } return table; } public int Match(string target) { var i = pattern.Length - 1; while (i < target.Length) { var p = pattern.Length - 1; while (p >= 0 && i < target.Length) { if (target[i] == pattern[p]) { i--; p--; } else { break; } } if (p < 0) return i + 1; var shift1 = table.ContainsKey(pattern[p]) ? table[pattern[p]] : pattern.Length; var shift2 = pattern.Length - p; i += Math.Max(shift1, shift2); } return -1; } } }"),
new AclFileInfo(@"DataStructure/String/KMP.cs", new string[] { @"AtCoder.DataStructure.String.KMP" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.DataStructure.String { public class KMP { readonly string pattern; readonly int[] table; public KMP(string pattern) { this.pattern = pattern; table = CreateTable(pattern); } static int[] CreateTable(string pattern) { var table = new int[pattern.Length + 1]; table[0] = -1; int j = -1; for (int i = 0; i < pattern.Length; i++) { while (j >= 0 && pattern[i] != pattern[j]) j = table[j]; table[i + 1] = ++j; } return table; } public IEnumerable<int> Matches(string target) { for (int i = 0, p = 0; i < target.Length;) { if (target[i] == pattern[p]) { i++; p++; } else if (p == 0) i++; else p = table[p]; if (p == pattern.Length) { yield return i - p; p = table[p]; } } } } }"),
new AclFileInfo(@"DataStructure/BIT/StarrySkyTree.cs", new string[] { @"AtCoder.DataStructure.Bit.StarrySkyTree", @"AtCoder.DataStructure.Bit.StarrySkyTree.KeyValuePairs", @"AtCoder.DataStructure.Bit.StarrySkyTree.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs" }, @"namespace AtCoder.DataStructure.Bit { [System.Diagnostics.DebuggerTypeProxy(typeof(DebugView))] class StarrySkyTree { protected virtual long DefaultValue => default; protected virtual long OpDefault => default; protected virtual long Merge(long v1, long v2) => Math.Max(v1, v2); readonly long[] lazy; readonly long[] data; public readonly int rootLength; public int Length { get; } public StarrySkyTree(int size) { this.Length = size; rootLength = 1 << (MSB(size - 1) + 1); lazy = NewArray((rootLength << 1) - 1, DefaultValue); data = NewArray((rootLength << 1) - 1, DefaultValue); } public void Add(int from, int toExclusive, long value) { void Add(int from, int toExclusive, long val, int k, int l, int r) { if (r <= from || toExclusive <= l) return; if (from <= l && r <= toExclusive) { data[k] += val; return; } int left = k * 2 + 1, right = k * 2 + 2; Add(from, toExclusive, val, left, l, (l + r) / 2); Add(from, toExclusive, val, right, (l + r) / 2, r); lazy[k] = Merge(lazy[left] + data[left], lazy[right] + data[right]); } Add(from, toExclusive, value, 0, 0, rootLength); } public long Slice(int from, int length) => Query(from, from + length); public long Query(int from, int toExclusive) { long Query(int from, int toExclusive, int k, int l, int r) { if (r <= from || toExclusive <= l) return DefaultValue; if (from <= l && r <= toExclusive) return lazy[k] + data[k]; return Merge(Query(from, toExclusive, k * 2 + 1, l, (l + r) / 2), Query(from, toExclusive, k * 2 + 2, (l + r) / 2, r)) + data[k]; } return Query(from, toExclusive, 0, 0, rootLength); } [System.Diagnostics.DebuggerDisplay(""{"" + nameof(value) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] struct KeyValuePairs { readonly string key; (long data, long lazy) value; public KeyValuePairs(string key, (long data, long lazy) value) { this.key = key; this.value = value; } } class DebugView { readonly StarrySkyTree tree; public DebugView(StarrySkyTree tree) { this.tree = tree; } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.RootHidden)] public KeyValuePairs[] Tree { get { var keys = new List<KeyValuePairs>(tree.lazy.Length); for (var len = tree.rootLength; len > 0; len >>= 1) { var unit = tree.rootLength / len; for (var i = 0; i < len; i++) { var index = i + len - 1; if (unit == 1) keys.Add(new KeyValuePairs($""[{i}]"", (tree.data[index], tree.lazy[index]))); else { var from = i * unit; keys.Add(new KeyValuePairs($""[{from}-{from + unit})"", (tree.data[index], tree.lazy[index]))); } } } return keys.ToArray(); } } } } }"),
new AclFileInfo(@"DataStructure/BIT/BinaryIndexedTreeRange.cs", new string[] { @"AtCoder.DataStructure.Bit.BinaryIndexedTreeRange" }, new string[] {  }, new string[] {  }, @"namespace AtCoder.DataStructure.Bit { public class BinaryIndexedTreeRange { void Add(long[] tree, int i, long w) { for (++i; i < tree1.Length; i += (i & -i)) tree[i] += w; } public void Add(int from, int to, long w) { Add(tree1, from, -w * from); Add(tree1, to, w * to); Add(tree2, from, w); Add(tree2, to, -w); } long Sum(long[] tree, int toExclusive) { long res = 0; for (var i = toExclusive; i > 0; i -= (i & -i)) res += tree[i]; return res; } public long Sum(int toExclusive) => Sum(tree1, toExclusive) + Sum(tree2, toExclusive) * toExclusive; public long Sum(int from, int toExclusive) => Sum(toExclusive) - Sum(from); readonly long[] tree1; readonly long[] tree2; public int Length => tree1.Length - 1; public long Slice(int from, int length) => Sum(from, from + length); public BinaryIndexedTreeRange(int size) { tree1 = new long[size + 1]; tree2 = new long[size + 1]; } } }"),
new AclFileInfo(@"DataStructure/BIT/BinaryIndexedTree2D.cs", new string[] { @"AtCoder.DataStructure.Bit.BinaryIndexedTree2D", @"AtCoder.DataStructure.Bit.BinaryIndexedTree2D.Slicer" }, new string[] {  }, new string[] {  }, @"namespace AtCoder.DataStructure.Bit { public class BinaryIndexedTree2D { public void Add(int h, int w, long v) { for (var hh = h + 1; hh < tree.Length; hh += (hh & -hh)) for (var ww = w + 1; ww < tree[hh].Length; ww += (ww & -ww)) tree[hh][ww] += v; } public long Query(int hExclusive, int wExclusive) { long res = 0; for (var h = hExclusive; h > 0; h -= (h & -h)) for (var w = wExclusive; w > 0; w -= (w & -w)) res += tree[h][w]; return res; } readonly long[][] tree; public int Length => tree.Length - 1; public Slicer Slice(int from, int length) => new Slicer(this, from, from + length); public BinaryIndexedTree2D(int H, int W) { tree = new long[H + 1][]; for (int i = 0; i < tree.Length; i++) tree[i] = new long[W + 1]; } public ref struct Slicer { readonly BinaryIndexedTree2D bit; readonly int hFrom; readonly int hToExclusive; public int Length { get; } public Slicer(BinaryIndexedTree2D bit, int hFrom, int hToExclusive) { this.bit = bit; this.hFrom = hFrom; this.hToExclusive = hToExclusive; this.Length = bit.tree[0].Length - 1; } public long Slice(int wFrom, int length) { var wToExclusive = wFrom + length; return bit.Query(hToExclusive, wToExclusive) - bit.Query(hToExclusive, wFrom) - bit.Query(hFrom, wToExclusive) + bit.Query(hFrom, wFrom); } } } }"),
new AclFileInfo(@"Math/Internal/InternalMath.cs", new string[] { @"AtCoder.Internal.InternalMath" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Math/MathLib.cs" }, @"namespace AtCoder.Internal { public static class InternalMath { public static long SafeMod(long x, long m) { x %= m; if (x < 0) x += m; return x; } public static (long, long) InvGCD(long a, long b) { a = SafeMod(a, b); if (a == 0) return (b, 0); long s = b, t = a; long m0 = 0, m1 = 1; long u; while (true) { if (t == 0) { if (m0 < 0) m0 += b / s; return (s, m0); } u = s / t; s -= t * u; m0 -= m1 * u; if (s == 0) { if (m1 < 0) m1 += b / t; return (t, m1); } u = t / s; t -= s * u; m1 -= m0 * u; } } private static readonly Dictionary<int, int> primitiveRootsCache = new Dictionary<int, int>() { { 2, 1 }, { 167772161, 3 }, { 469762049, 3 }, { 754974721, 11 }, { 998244353, 3 } }; public static int PrimitiveRoot(int m) { Debug.Assert(m >= 2); if (primitiveRootsCache.TryGetValue(m, out var p)) { return p; } return primitiveRootsCache[m] = Calculate(m); int Calculate(int m) { Span<int> divs = stackalloc int[20]; divs[0] = 2; int cnt = 1; int x = (m - 1) / 2; while (x % 2 == 0) { x >>= 1; } for (int i = 3; (long)i * i <= x; i += 2) { if (x % i == 0) { divs[cnt++] = i; while (x % i == 0) { x /= i; } } } if (x > 1) { divs[cnt++] = x; } for (int g = 2; ; g++) { bool ok = true; for (int i = 0; i < cnt; i++) { if (MathLib.PowMod(g, (m - 1) / divs[i], m) == 1) { ok = false; break; } } if (ok) { return g; } } } } } } "),
new AclFileInfo(@"Math/Internal/Butterfly.cs", new string[] { @"AtCoder.Internal.Butterfly<T>" }, new string[] { @"using System;" }, new string[] { @"Math/ModSeed.cs", @"Math/StaticModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder.Internal { public static class Butterfly<T> where T : struct, IStaticMod { private static StaticModInt<T>[] sumE = CalcurateSumE(); private static StaticModInt<T>[] sumIE = CalcurateSumIE(); public static void Calculate(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = 1; ph <= h; ph++) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var now = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p] * now; a[i + offset] = l + r; a[i + offset + p] = l - r; } now *= sumE[InternalBit.BSF(~(uint)s)]; } } } public static void CalculateInv(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = h; ph >= 1; ph--) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var iNow = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p]; a[i + offset] = l + r; a[i + offset + p] = StaticModInt<T>.Raw( unchecked((int)((ulong)(default(T).Mod + l.Value - r.Value) * (ulong)iNow.Value % default(T).Mod))); } iNow *= sumIE[InternalBit.BSF(~(uint)s)]; } } } private static StaticModInt<T>[] CalcurateSumE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumE.Length; i++) { sumE[i] = es[i] * now; now *= ies[i]; } return sumE; } private static StaticModInt<T>[] CalcurateSumIE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumIE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumIE.Length; i++) { sumIE[i] = ies[i] * now; now *= es[i]; } return sumIE; } } } "),
new AclFileInfo(@"Math/Internal/Barrett.cs", new string[] { @"AtCoder.Internal.Barrett" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Numerics;", @"using System.Runtime.Intrinsics;", @"using System.Runtime.Intrinsics.X86;", @"using System.Text;" }, new string[] {  }, @"namespace AtCoder.Internal { public class Barrett { public uint Mod { get; private set; } private ulong IM; public Barrett(uint m) { Mod = m; IM = unchecked((ulong)-1) / m + 1; } public uint Mul(uint a, uint b) { ulong z = a; z *= b; if (!Bmi2.X64.IsSupported) return (uint)(z % Mod); var x = Bmi2.X64.MultiplyNoFlags(z, IM); var v = unchecked((uint)(z - x * Mod)); if (Mod <= v) v += Mod; return v; } } } "),
new AclFileInfo(@"Util/Internal/CollectionDebugView.cs", new string[] { @"AtCoder.Util.Internal.CollectionDebugView<T>" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Util.Internal { internal class CollectionDebugView<T> { private readonly IEnumerable<T> collection; public CollectionDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); } } "),
new AclFileInfo(@"Util/Memo/GridMemo.cs", new string[] { @"AtCoder.Util.Memo.GridMemo" }, new string[] { @"using AtCoder.IO;", @"using System;", @"using System.Collections.Generic;", @"using System.Linq;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"IO/ConsoleReader.cs" }, @"namespace AtCoder.Util.Memo { internal class GridMemo { readonly ConsoleReader cr; public GridMemo(ConsoleReader cr) { this.cr = cr; } public object Calc() { var H = cr.Int; var W = cr.Int; var grid = cr.Repeat(H).Ascii; var bfs = NewArray(H, W, 100000); bfs[0][0] = 1; var queue = new Queue<(int h, int w)>(); queue.Enqueue((0, 0)); while (queue.Count > 0) { var (h, w) = queue.Dequeue(); if (h > 0 && grid[h - 1][w] == '.') if (bfs[h - 1][w].UpdateMin(bfs[h][w] + 1)) queue.Enqueue((h - 1, w)); if (h + 1 < H && grid[h + 1][w] == '.') if (bfs[h + 1][w].UpdateMin(bfs[h][w] + 1)) queue.Enqueue((h + 1, w)); if (w > 0 && grid[h][w - 1] == '.') if (bfs[h][w - 1].UpdateMin(bfs[h][w] + 1)) queue.Enqueue((h, w - 1)); if (w + 1 < W && grid[h][w + 1] == '.') if (bfs[h][w + 1].UpdateMin(bfs[h][w] + 1)) queue.Enqueue((h, w + 1)); } return Math.Max(grid.SelectMany(st => st).Count(c => c == '.') - bfs[H - 1][W - 1], -1); } } } "),
new AclFileInfo(@"Bit/Internal/InternalBit.cs", new string[] { @"AtCoder.Internal.InternalBit" }, new string[] { @"using System.Diagnostics;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using System.Runtime.Intrinsics.X86;" }, new string[] {  }, @"namespace AtCoder.Internal { public static class InternalBit { public static int CeilPow2(int n) { var un = (uint)n; if (un <= 1) return 0; return BitOperations.Log2(un - 1) + 1; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int ExtractLowestSetBit(int n) { if (Bmi1.IsSupported) { return (int)Bmi1.ExtractLowestSetBit((uint)n); } return n & -n; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int BSF(uint n) { Debug.Assert(n >= 1); return BitOperations.TrailingZeroCount(n); } } } "),
new AclFileInfo(@"Graph//GraphUtil.cs", new string[] { @"AtCoder.Graph.WGraphUtil", @"AtCoder.Graph.WGraphUtil.PriorityQueue<T>", @"AtCoder.Graph.WGraphUtil.PriorityQueue<TKey, TValue>", @"AtCoder.Graph.WGraphUtil.PriorityQueue<TKey, TValue>.KeyComparer" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"Extensions.cs", @"Graph//.cs" }, @"namespace AtCoder.Graph { public static class WGraphUtil { [System.Diagnostics.DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] class PriorityQueue<T> { protected readonly List<T> data; protected readonly IComparer<T> comparer; public PriorityQueue() : this(Comparer<T>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<T>.Default) { } public PriorityQueue(IComparer<T> comparer) { this.data = new List<T>(); this.comparer = comparer; } public PriorityQueue(int capacity, IComparer<T> comparer) { this.data = new List<T>(capacity); this.comparer = comparer; }[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public int Count => data.Count; public T Peek => data[0]; public void Add(T value) { data.Add(value); UpdateUp(data.Count - 1); } public T Dequeue() { var res = data[0]; data[0] = data[^1]; data.RemoveAt(data.Count - 1); UpdateDown(0); return res; } void UpdateUp(int i) { if (i > 0) { var p = (i - 1) >> 1; if (comparer.Compare(data[i], data[p]) < 0) { (data[p], data[i]) = (data[i], data[p]); UpdateUp(p); } } } void UpdateDown(int i) { var n = data.Count; var child = 2 * i + 1; if (child < n) { if (child != n - 1 && comparer.Compare(data[child], data[child + 1]) > 0) child++; if (comparer.Compare(data[i], data[child]) > 0) { (data[child], data[i]) = (data[i], data[child]); UpdateDown(child); } } }[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.RootHidden)] T[] Items => data.ToArray().Sort((a, b) => comparer.Compare(a, b)); } class PriorityQueue<TKey, TValue> : PriorityQueue<KeyValuePair<TKey, TValue>> { class KeyComparer : IComparer<KeyValuePair<TKey, TValue>> { public readonly IComparer<TKey> comparer; public KeyComparer(IComparer<TKey> comparer) { this.comparer = comparer; } public int Compare(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y) => comparer.Compare(x.Key, y.Key); } public PriorityQueue() : this(Comparer<TKey>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<TKey>.Default) { } public PriorityQueue(IComparer<TKey> comparer) : base(new KeyComparer(comparer)) { } public PriorityQueue(int capacity, IComparer<TKey> comparer) : base(capacity, new KeyComparer(comparer)) { } public void Add(TKey key, TValue value) => Add(new KeyValuePair<TKey, TValue>(key, value)); } public static int MaxFlow(this WNode[] graph, int from, int to) { var capacities = new Dictionary<(int from, int to), int>(); for (int i = 0; i < graph.Length; i++) foreach (var next in graph[i].children) capacities.Add((i, next.to), next.value); var children = new HashSet<int>[graph.Length]; for (int i = 0; i < children.Length; i++) children[i] = new HashSet<int>(graph[i].children.Select(c => c.to)); var ret = 0; while (true) { var routes = new (int from, int to)[children.Length][]; var queue = new Queue<int>(children.Length); routes[from] = Array.Empty<ValueTuple<int, int>>(); queue.Enqueue(from); while (queue.Count > 0 && routes[to] == null) { var cur = queue.Dequeue(); foreach (var child in children[cur]) { var route = (cur, child); if (routes[child] == null && capacities[route] > 0) { routes[child] = new (int from, int to)[routes[cur].Length + 1]; routes[cur].CopyTo(routes[child], 0); routes[child][^1] = route; queue.Enqueue(child); } } } if (routes[to] == null) return ret; var min = int.MaxValue; foreach (var route in routes[to]) min = Math.Min(min, capacities[route]); ret += min; foreach (var route in routes[to]) { capacities[route] -= min; var rev = (route.to, route.from); children[route.to].Add(route.from); capacities.TryGetValue(rev, out int v); capacities[rev] = v + min; } } } public static long[][] WarshallFloyd(this WNode[] graph) { var res = NewArray(graph.Length, graph.Length, 0L); for (var i = 0; i < graph.Length; i++) { for (var j = 0; j < graph.Length; j++) { res[i][j] = long.MaxValue / 2; } res[i][i] = 0; foreach (var next in graph[i].children) res[i][next.to] = next.value; } for (var k = 0; k < graph.Length; k++) for (var i = 0; i < graph.Length; i++) for (var j = 0; j < graph.Length; j++) if (res[i][j] > res[i][k] + res[k][j]) res[i][j] = res[i][k] + res[k][j]; return res; } public static long[] Dijkstra(this WNode[] graph, int start) { var res = NewArray(graph.Length, long.MaxValue / 2); res[start] = 0; var used = new bool[graph.Length]; int count = 0; var remains = new PriorityQueue<long, int>(); remains.Add(0, start); while (remains.Count > 0) { var first = remains.Dequeue(); if (used[first.Value]) continue; used[first.Value] = true; if (++count >= graph.Length) break; foreach (var next in graph[first.Value].children) { var nextLength = first.Key + next.value; if (res[next.to] > nextLength) remains.Add(res[next.to] = nextLength, next.to); } } return res; } public static long[] BellmanFord(this WNode[] graph, int start) { var res = NewArray(graph.Length, long.MaxValue / 2); res[start] = 0; for (int i = 1; i <= graph.Length; i++) foreach (var node in graph) foreach (var next in node.children) if (res[next.to].UpdateMin(res[node.index] + next.value)) if (i == graph.Length) throw new InvalidOperationException(""""); return res; } public static WNode[] Prim(this WNode[] graph) { var sumi = new bool[graph.Length]; var pq = new PriorityQueue<int, (int from, int to)>(); var gb = new WGraphBuilder(graph.Length, false); sumi[0] = true; foreach (var next in graph[0].children) pq.Add(next.value, (0, next.to)); for (int i = 1; i < graph.Length; i++) { var t = pq.Dequeue(); if (sumi[t.Value.to]) { --i; continue; } sumi[t.Value.to] = true; gb.Add(t.Value.from, t.Value.to, t.Key); foreach (var next in graph[t.Value.to].children) if (!sumi[next.to]) pq.Add(next.value, (t.Value.to, next.to)); } return gb.ToArray(); } } }"),
new AclFileInfo(@"Graph//.cs", new string[] { @"AtCoder.Graph." }, new string[] { @"using AtCoder.Collection;", @"using AtCoder.GraphAcl;", @"using System.Collections.Generic;" }, new string[] { @"Graph//.cs", @"GraphAcl/DSU.cs", @"Collection/PriorityQueue.cs" }, @"namespace AtCoder.Graph { public static class  { public static WNode[] Kruskal(this WNode[] graph) { var gb = new WGraphBuilder(graph.Length, false); var uf = new DSU(graph.Length); var edges = new List<(int from, int to, int value)>(); foreach (var node in graph) foreach (var next in node.children) edges.Add((node.index, next.to, next.value)); edges.Sort(Comparer<(int from, int to, int value)>.Create((t1, t2) => t1.value.CompareTo(t2.value))); foreach (var (from, to, value) in edges) { if (!uf.Same(from, to)) { uf.Merge(from, to); gb.Add(from, to, value); } } return gb.ToArray(); } public static WNode[] Prim(this WNode[] graph) { var sumi = new bool[graph.Length]; var pq = new PriorityQueue<int, (int from, int to)>(); var gb = new WGraphBuilder(graph.Length, false); sumi[0] = true; foreach (var next in graph[0].children) pq.Add(next.value, (0, next.to)); for (int i = 1; i < graph.Length; i++) { var t = pq.Dequeue(); if (sumi[t.Value.to]) { --i; continue; } sumi[t.Value.to] = true; gb.Add(t.Value.from, t.Value.to, t.Key); foreach (var next in graph[t.Value.to].children) if (!sumi[next.to]) pq.Add(next.value, (t.Value.to, next.to)); } return gb.ToArray(); } } }"),
new AclFileInfo(@"Graph//.cs", new string[] { @"AtCoder.Graph.WGraphBuilderD", @"AtCoder.Graph.NextD", @"AtCoder.Graph.WTreeNodeD", @"AtCoder.Graph.WNodeD", @"AtCoder.Graph.MinCostFlow", @"AtCoder.Graph.MinCostFlow.Node" }, new string[] { @"using AtCoder;", @"using AtCoder.Collection;", @"using AtCoder.IO;", @"using System;", @"using System.Collections.Generic;", @"using System.Linq;", @"using static AtCoder.Global;" }, new string[] { @"Global.cs", @"IO/ConsoleReader.cs", @"Collection/PriorityQueue.cs", @"Extensions.cs" }, @"namespace AtCoder.Graph { public class WGraphBuilderD { List<NextD>[] roots; List<NextD>[] children; public WGraphBuilderD(int count, bool isOriented) { this.roots = new List<NextD>[count]; this.children = new List<NextD>[count]; for (var i = 0; i < count; i++) { if (isOriented) { this.roots[i] = new List<NextD>(); this.children[i] = new List<NextD>(); } else { this.roots[i] = this.children[i] = new List<NextD>(); } } } public WGraphBuilderD(int count, ConsoleReader cr, int edgeCount, bool isOriented) : this(count, isOriented) { for (var i = 0; i < edgeCount; i++) this.Add(cr.Int0, cr.Int0, cr.Int, cr.Int); } public static WTreeNodeD[] MakeTree(int count, ConsoleReader cr, int root = 0) => new WGraphBuilderD(count, cr, count - 1, false).ToTree(root); public void Add(int from, int to, int capacity, long cost) { children[from].Add(new NextD { to = to, capacity = capacity, cost = cost }); roots[to].Add(new NextD { to = from, capacity = capacity, cost = cost }); } public WNodeD[] ToArray() => Enumerable .Zip(roots, children, (root, child) => (root, child)) .Select((t, i) => new WNodeD(i, t.root.ToArray(), t.child.ToArray())) .ToArray(); public WTreeNodeD[] ToTree(int root = 0) { if (this.roots[0] != this.children[0]) throw new Exception(""""); var res = new WTreeNodeD[this.children.Length]; res[root] = new WTreeNodeD(root, -1, 0, 0, this.children[root].ToArray()); var queue = new Queue<int>(); foreach (var child in res[root].children) { res[child.to] = new WTreeNodeD(child.to, root, 1, child.cost, Array.Empty<NextD>()); queue.Enqueue(child.to); } while (queue.Count > 0) { var from = queue.Dequeue(); if (res[from].root == -1) res[from].children = this.children[from].ToArray(); else { var children = new List<NextD>(this.children[from].Count); foreach (var c in this.children[from]) if (c.to != res[from].root) children.Add(c); res[from].children = children.ToArray(); } foreach (var child in res[from].children) { res[child.to] = new WTreeNodeD(child.to, from, res[from].depth + 1, res[from].depthLength + child.cost, Array.Empty<NextD>()); queue.Enqueue(child.to); } } return res; } public WGraphBuilderD Clone() { var count = this.roots.Length; var isOriented = this.roots[0] != this.children[0]; var cl = new WGraphBuilderD(count, isOriented); for (int i = 0; i < count; i++) { if (isOriented) { cl.children[i] = this.children[i].ToList(); cl.roots[i] = this.roots[i].ToList(); } else cl.children[i] = cl.roots[i] = this.roots[i].ToList(); } return cl; } } public struct NextD { public int to; public int capacity; public long cost; public void Deconstruct(out int to, out int capacity, out long cost) { to = this.to; capacity = this.capacity; cost = this.cost; } public override string ToString() => $""to: {to} value:{capacity}/{cost}""; } public class WTreeNodeD { public WTreeNodeD(int i, int root, int depth, long depthLength, NextD[] children) { this.index = i; this.root = root; this.children = children; this.depth = depth; this.depthLength = depthLength; } public readonly int index; public readonly int root; public readonly int depth; public readonly long depthLength; public NextD[] children; public override string ToString() => $""children: {string.Join("","", children)}""; public override bool Equals(object obj) => obj is WTreeNodeD d && this.Equals(d); public bool Equals(WTreeNodeD other) => this.index == other.index; public override int GetHashCode() => this.index; } public class WNodeD { public WNodeD(int i, NextD[] roots, NextD[] children) { this.index = i; this.roots = roots; this.children = children; } public int index; public NextD[] roots; public NextD[] children; public override bool Equals(object obj) => obj is WNodeD d && this.Equals(d); public bool Equals(WNodeD other) => this.index == other.index; public override int GetHashCode() => this.index; public override string ToString() => $""children: ({string.Join(""),("", children)})""; } class MinCostFlow { const long INF = long.MaxValue >> 3; Node[][] graph; public MinCostFlow(WNodeD[] orig) { var gb = NewArray(orig.Length, () => new List<Node>()); for (int i = 0; i < orig.Length; i++) { foreach (var next in orig[i].children) { gb[i].Add(new Node(next.to, next.capacity, next.cost, gb[next.to].Count, false)); gb[next.to].Add(new Node(i, 0, -next.cost, gb[i].Count - 1, true)); } } graph = gb.Select(l => l.ToArray()).ToArray(); } class Node { public Node(NextD next, int rev, bool isReverse) : this(next.to, next.capacity, next.cost, rev, isReverse) { } public Node(int to, int capacity, long cost, int rev, bool isReverse) { this.to = to; this.capacity = capacity; this.cost = cost; this.rev = rev; this.isReverse = isReverse; } public int to; public int capacity; public long cost; public int rev; public bool isReverse; public override string ToString() => $""to: {to} value:{capacity}/{cost}""; } public long Calc(int from, int to, int flow) { long res = 0; var pq = new PriorityQueue<long, int>(graph.Length); var potential = new long[graph.Length]; var preve = NewArray(graph.Length, -1); var prevv = NewArray(graph.Length, -1); while (flow > 0) { var minCosts = NewArray(graph.Length, INF); pq.Add(0, from); minCosts[from] = 0; while (pq.Count > 0) { var (cost, v) = pq.Dequeue(); if (minCosts[v] < cost) continue; for (int i = 0; i < graph[v].Length; i++) { var next = graph[v][i]; var nxCost = minCosts[v] + next.cost + potential[v] - potential[next.to]; if (next.capacity > 0 && minCosts[next.to].UpdateMin(nxCost)) { prevv[next.to] = v; preve[next.to] = i; pq.Add(minCosts[next.to], next.to); } } } if (minCosts[to] == INF) return -1; for (int v = 0; v < potential.Length; v++) potential[v] += minCosts[v]; var addflow = flow; for (int v = to; v != from; v = prevv[v]) addflow.UpdateMin(graph[prevv[v]][preve[v]].capacity); flow -= addflow; res += addflow * potential[to]; for (int v = to; v != from; v = prevv[v]) { var next = graph[prevv[v]][preve[v]]; next.capacity -= addflow; graph[v][next.rev].capacity += addflow; } } return res; } } }"),
new AclFileInfo(@"Graph//.cs", new string[] { @"AtCoder.Graph.WGraphBuilder", @"AtCoder.Graph.Next", @"AtCoder.Graph.WTreeNode", @"AtCoder.Graph.WNode" }, new string[] { @"using AtCoder.IO;", @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] { @"IO/ConsoleReader.cs" }, @"namespace AtCoder.Graph { public class WGraphBuilder { readonly List<Next>[] roots; readonly List<Next>[] children; public WGraphBuilder(int count, bool isOriented) { this.roots = new List<Next>[count]; this.children = new List<Next>[count]; for (var i = 0; i < count; i++) { if (isOriented) { this.roots[i] = new List<Next>(); this.children[i] = new List<Next>(); } else { this.roots[i] = this.children[i] = new List<Next>(); } } } public WGraphBuilder(int count, ConsoleReader cr, int edgeCount, bool isOriented) : this(count, isOriented) { for (var i = 0; i < edgeCount; i++) this.Add(cr.Int0, cr.Int0, cr.Int); } public static WTreeNode[] MakeTree(int count, ConsoleReader cr, int root = 0) => new WGraphBuilder(count, cr, count - 1, false).ToTree(root); public void Add(int from, int to, int value) { children[from].Add(new Next { to = to, value = value }); roots[to].Add(new Next { to = from, value = value }); } public WNode[] ToArray() => Enumerable .Zip(roots, children, (root, child) => (root, child)) .Select((t, i) => new WNode(i, t.root.ToArray(), t.child.ToArray())) .ToArray(); public WTreeNode[] ToTree(int root = 0) { if (this.roots[0] != this.children[0]) throw new Exception(""""); var res = new WTreeNode[this.children.Length]; res[root] = new WTreeNode(root, -1, 0, 0, this.children[root].ToArray()); var queue = new Queue<int>(); foreach (var child in res[root].children) { res[child.to] = new WTreeNode(child.to, root, 1, child.value, Array.Empty<Next>()); queue.Enqueue(child.to); } while (queue.Count > 0) { var from = queue.Dequeue(); if (res[from].root == -1) res[from].children = this.children[from].ToArray(); else { var children = new List<Next>(this.children[from].Count); foreach (var c in this.children[from]) if (c.to != res[from].root) children.Add(c); res[from].children = children.ToArray(); } foreach (var child in res[from].children) { res[child.to] = new WTreeNode(child.to, from, res[from].depth + 1, res[from].depthLength + child.value, Array.Empty<Next>()); queue.Enqueue(child.to); } } return res; } public WGraphBuilder Clone() { var count = this.roots.Length; var isOriented = this.roots[0] != this.children[0]; var cl = new WGraphBuilder(count, isOriented); for (int i = 0; i < count; i++) { if (isOriented) { cl.children[i] = this.children[i].ToList(); cl.roots[i] = this.roots[i].ToList(); } else cl.children[i] = cl.roots[i] = this.roots[i].ToList(); } return cl; } } public struct Next { public int to; public int value; public void Deconstruct(out int to, out int value) { to = this.to; value = this.value; } public override string ToString() => $""to: {to} value:{value}""; } public class WTreeNode { public WTreeNode(int i, int root, int depth, long depthLength, Next[] children) { this.index = i; this.root = root; this.children = children; this.depth = depth; this.depthLength = depthLength; } public readonly int index; public readonly int root; public readonly int depth; public readonly long depthLength; public Next[] children; public override string ToString() => $""children: {string.Join("","", children)}""; public override bool Equals(object obj) => obj is WTreeNode d && this.Equals(d); public bool Equals(WTreeNode other) => this.index == other.index; public override int GetHashCode() => this.index; } public class WNode { public WNode(int i, Next[] roots, Next[] children) { this.index = i; this.roots = roots; this.children = children; } public int index; public Next[] roots; public Next[] children; public override bool Equals(object obj) => obj is WNode d && this.Equals(d); public bool Equals(WNode other) => this.index == other.index; public override int GetHashCode() => this.index; public override string ToString() => $""children: ({string.Join(""),("", children)})""; } }"),
new AclFileInfo(@"GraphAcl/Internal/InternalSCCGraph.cs", new string[] { @"AtCoder.GraphAcl.Internal.SCCGraph", @"AtCoder.GraphAcl.Internal.SCCGraph.CSR", @"AtCoder.GraphAcl.Internal.SCCGraph.Edge" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.GraphAcl.Internal { [DebuggerDisplay(""Vertices = {_n}, Edges = {edges.Count}"")] public class SCCGraph { private readonly int _n; private readonly List<Edge> edges; public int VerticesNumbers => _n; public SCCGraph(int n) { _n = n; edges = new List<Edge>(); } public void AddEdge(int from, int to) => edges.Add(new Edge(from, to)); public (int groupNum, int[] ids) SCCIDs() { var g = new CSR(_n, edges); int nowOrd = 0; int groupNum = 0; var visited = new Stack<int>(_n); var low = new int[_n]; var ord = Enumerable.Repeat(-1, _n).ToArray(); var ids = new int[_n]; for (int i = 0; i < ord.Length; i++) { if (ord[i] == -1) { DFS(i); } } foreach (ref var x in ids.AsSpan()) { x = groupNum - 1 - x; } return (groupNum, ids); void DFS(int v) { low[v] = nowOrd; ord[v] = nowOrd++; visited.Push(v); for (int i = g.Start[v]; i < g.Start[v + 1]; i++) { int to = g.EList[i]; if (ord[to] == -1) { DFS(to); low[v] = Math.Min(low[v], low[to]); } else { low[v] = Math.Min(low[v], ord[to]); } } if (low[v] == ord[v]) { while (true) { int u = visited.Pop(); ord[u] = _n; ids[u] = groupNum; if (u == v) { break; } } groupNum++; } } } public List<List<int>> SCC() { var (groupNum, ids) = SCCIDs(); var counts = new int[groupNum]; foreach (var x in ids) { counts[x]++; } var groups = new List<List<int>>(groupNum); for (int i = 0; i < groupNum; i++) { groups.Add(new List<int>(counts[i])); } for (int i = 0; i < ids.Length; i++) { groups[ids[i]].Add(i); } return groups; } private class CSR { public int[] Start { get; } public int[] EList { get; } public CSR(int n, List<Edge> edges) { Start = new int[n + 1]; EList = new int[edges.Count]; foreach (var e in edges) { Start[e.From + 1]++; } for (int i = 1; i <= n; i++) { Start[i] += Start[i - 1]; } var counter = new int[Start.Length]; Start.CopyTo(counter, 0); foreach (var e in edges) { EList[counter[e.From]++] = e.To; } } } [DebuggerDisplay(""From = {From}, To = {To}"")] private readonly struct Edge { public int From { get; } public int To { get; } public Edge(int from, int to) { From = from; To = to; } } } } "),
            });
    }
}
